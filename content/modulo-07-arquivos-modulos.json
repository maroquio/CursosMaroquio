{
  "module": {
    "id": "modulo-07",
    "title": "Arquivos, Módulos e Pacotes",
    "description": "Neste módulo, você aprenderá a trabalhar com arquivos, módulos e pacotes em Python. Você irá abrir, ler e criar arquivos, bem como usar os recursos de gerenciamento de arquivos para manipulá-los em um sistema de arquivos, copiando, movendo, excluindo, compactando e descompactando arquivos e diretórios. Além disso, você aprenderá a importar e a utilizar módulos e pacotes em Python, incluindo módulos e pacotes de terceiros e módulos e pacotes criados por você mesmo.",
    "order": 7
  },
  "lessons": [
    {
      "id": "lesson-07-01",
      "title": "Trabalhando com Arquivos em Python",
      "slug": "trabalhando-com-arquivos",
      "description": "Aprenda a abrir, ler e escrever arquivos em Python usando a função open e a instrução with.",
      "order": 1,
      "estimatedMinutes": 20,
      "sections": [
        {
          "id": "section-07-01-01",
          "title": "Abrindo e Fechando Arquivos",
          "contentType": "text",
          "order": 1,
          "estimatedMinutes": 4,
          "content": {
            "body": "Uma importante funcionalidade da linguagem Python é a capacidade de ler e escrever em arquivos de forma bem simplificada. Arquivos são o meio mais primitivo de se armazenar dados para uso futuro em um programa.\n\nAntes de ler ou escrever em um arquivo, é necessário abri-lo. Em Python, usamos a função `open` para abrir arquivos. Quando chamada com um único argumento, tal argumento corresponde ao nome do arquivo a ser aberto, e o modo de abertura será automaticamente o modo para leitura (`r`).\n\nQuando a função `open` é chamada com dois argumentos, o primeiro continua sendo o nome do arquivo e o segundo corresponde ao modo de abertura:\n\n- `r` - modo de leitura\n- `w` - modo de escrita (sobrescreve o arquivo)\n- `a` - modo de acréscimo (adiciona ao final do arquivo)\n\n```python\narquivo = open(\"meuarquivo.txt\", \"r\")\n```\n\nPara fechar um arquivo previamente aberto, chamamos a função `close` a partir da variável que referencia o arquivo:\n\n```python\narquivo.close()\n```\n\nÉ importante sempre fechar o arquivo após seu uso para garantir que o arquivo seja salvo corretamente e para liberar recursos do sistema.\n\nA função `open` possui um parâmetro `encoding` que permite definir a codificação usada na leitura/escrita do arquivo. Para textos em português com caracteres acentuados, a codificação recomendada é UTF-8:\n\n```python\narquivo = open(\"meuarquivo.txt\", \"r\", encoding=\"utf-8\")\n```"
          }
        },
        {
          "id": "section-07-01-02",
          "title": "Lendo e Escrevendo em Arquivos",
          "contentType": "text",
          "order": 2,
          "estimatedMinutes": 5,
          "content": {
            "body": "Depois de abrir um arquivo, é possível ler ou escrever neste arquivo, dependendo do modo em que ele foi aberto.\n\n## Escrevendo em Arquivos\n\nA função `write` é usada para escrever conteúdo no arquivo:\n\n```python\narquivo = open(\"meuarquivo.txt\", \"w\", encoding=\"utf-8\")\narquivo.write(\"Este é o conteúdo do meu arquivo.\")\narquivo.close()\n```\n\n## Lendo Arquivos\n\nA função `read` lê todo o conteúdo de um arquivo de uma só vez. Já a função `readline` lê uma linha do arquivo de cada vez, e `readlines` retorna uma lista com todas as linhas.\n\nExemplo de leitura linha a linha:\n\n```python\narquivo = open(\"meuarquivo.txt\", \"r\", encoding=\"utf-8\")\nlinha = arquivo.readline()\nwhile linha:\n    print(linha)\n    linha = arquivo.readline()\narquivo.close()\n```\n\nNeste exemplo, usamos um laço `while` para ler cada linha do arquivo. Enquanto `readline()` retornar algo, o programa continuará lendo e exibindo as linhas.\n\n## Funções Adicionais\n\n- `seek(posicao)` - move o ponteiro de leitura/gravação para uma posição específica\n- `tell()` - retorna a posição atual do ponteiro\n- `writelines(lista)` - escreve várias linhas de uma vez"
          }
        },
        {
          "id": "section-07-01-03",
          "title": "Utilizando a Instrução with",
          "contentType": "text",
          "order": 3,
          "estimatedMinutes": 4,
          "content": {
            "body": "A instrução `with` em Python é uma forma conveniente de abrir um arquivo e garantir que ele seja fechado após o uso. O fechamento ocorre automaticamente ao final do bloco `with`, evitando que você esqueça de fechar o arquivo.\n\n```python\nwith open(\"meuarquivo.txt\", \"r\", encoding=\"utf-8\") as arquivo:\n    for linha in arquivo:\n        print(linha)\n```\n\nNeste exemplo, o arquivo é aberto em modo de leitura usando a instrução `with`. O bloco `for` percorre o arquivo linha a linha. O uso da instrução `with` garante que o arquivo seja fechado automaticamente após o uso.\n\n## Vantagens do with\n\n1. **Fechamento automático**: Não é necessário chamar `close()` explicitamente\n2. **Tratamento de erros**: Mesmo que ocorra uma exceção dentro do bloco, o arquivo será fechado\n3. **Código mais limpo**: Menos linhas de código e mais fácil de ler\n4. **Boas práticas**: É a forma recomendada de trabalhar com arquivos em Python\n\n## Exemplo de Escrita com with\n\n```python\nwith open(\"saida.txt\", \"w\", encoding=\"utf-8\") as arquivo:\n    arquivo.write(\"Linha 1\\n\")\n    arquivo.write(\"Linha 2\\n\")\n    arquivo.write(\"Linha 3\\n\")\n# Arquivo fechado automaticamente aqui\n```"
          }
        },
        {
          "id": "section-07-01-04",
          "title": "Exercício: Leitura e Escrita de Arquivos",
          "contentType": "exercise",
          "order": 4,
          "estimatedMinutes": 7,
          "content": {
            "problem": "Crie um programa que leia um arquivo texto, inverta o conteúdo de cada linha e salve o resultado em um novo arquivo.\n\nPor exemplo, se o arquivo de entrada contém:\n```\nPython\nProgramação\n```\n\nO arquivo de saída deve conter:\n```\nnohtyP\noãçamargorP\n```",
            "starterCode": "# Leia o arquivo 'entrada.txt' e escreva em 'saida.txt'\n# com cada linha invertida\n\n# Seu código aqui\n",
            "testCases": [
              {
                "input": "Python\\nProgramação\\n",
                "expectedOutput": "nohtyP\\noãçamargorP\\n",
                "description": "Deve inverter cada linha do arquivo"
              },
              {
                "input": "Hello World\\n123\\n",
                "expectedOutput": "dlroW olleH\\n321\\n",
                "description": "Deve funcionar com qualquer texto"
              }
            ],
            "hints": [
              "Use a instrução with para abrir ambos os arquivos",
              "Para inverter uma string, use a sintaxe de slicing: texto[::-1]",
              "Lembre-se de usar strip() para remover caracteres de nova linha antes de inverter"
            ],
            "solution": "with open('entrada.txt', 'r', encoding='utf-8') as entrada:\n    with open('saida.txt', 'w', encoding='utf-8') as saida:\n        for linha in entrada:\n            linha_invertida = linha.strip()[::-1]\n            saida.write(linha_invertida + '\\n')"
          }
        },
        {
          "id": "section-07-01-05",
          "title": "Quiz: Manipulação de Arquivos",
          "contentType": "quiz",
          "order": 5,
          "estimatedMinutes": 3,
          "content": {
            "questions": [
              {
                "id": "q1",
                "question": "Qual função é usada para abrir um arquivo em Python?",
                "options": [
                  "file()",
                  "open()",
                  "read()",
                  "load()"
                ],
                "correctAnswer": 1,
                "explanation": "A função open() é usada para abrir arquivos em Python. Ela retorna um objeto de arquivo que pode ser usado para ler ou escrever."
              },
              {
                "id": "q2",
                "question": "Qual modo de abertura permite adicionar conteúdo ao final de um arquivo existente sem apagar seu conteúdo?",
                "options": [
                  "r (read)",
                  "w (write)",
                  "a (append)",
                  "x (exclusive)"
                ],
                "correctAnswer": 2,
                "explanation": "O modo 'a' (append) permite adicionar conteúdo ao final do arquivo sem apagar o conteúdo existente. O modo 'w' sobrescreveria o arquivo."
              },
              {
                "id": "q3",
                "question": "Qual é a principal vantagem de usar a instrução 'with' ao trabalhar com arquivos?",
                "options": [
                  "É mais rápido para ler arquivos grandes",
                  "Permite ler arquivos binários",
                  "Garante que o arquivo seja fechado automaticamente",
                  "Permite abrir múltiplos arquivos ao mesmo tempo"
                ],
                "correctAnswer": 2,
                "explanation": "A principal vantagem do 'with' é garantir que o arquivo seja fechado automaticamente ao final do bloco, mesmo que ocorra uma exceção."
              },
              {
                "id": "q4",
                "question": "Qual método lê todas as linhas de um arquivo e retorna uma lista?",
                "options": [
                  "read()",
                  "readline()",
                  "readlines()",
                  "getlines()"
                ],
                "correctAnswer": 2,
                "explanation": "O método readlines() lê todas as linhas do arquivo e retorna uma lista onde cada elemento é uma linha do arquivo."
              }
            ]
          }
        }
      ]
    },
    {
      "id": "lesson-07-02",
      "title": "Gerenciamento de Arquivos e Diretórios",
      "slug": "gerenciamento-arquivos-diretorios",
      "description": "Aprenda a manipular diretórios e realizar operações em arquivos como exclusão, cópia, movimentação, compactação e descompactação.",
      "order": 2,
      "estimatedMinutes": 25,
      "sections": [
        {
          "id": "section-07-02-01",
          "title": "Trabalhando com Diretórios",
          "contentType": "text",
          "order": 1,
          "estimatedMinutes": 4,
          "content": {
            "body": "Além de ler e escrever arquivos, a linguagem Python possui funções e módulos integrados para lidar com o sistema de arquivos. O módulo `os` é usado para trabalhar com diretórios em Python.\n\n## Criando e Excluindo Diretórios\n\nO módulo `os` inclui funções úteis como `mkdir` para criar um novo diretório e `rmdir` para excluir um diretório existente (que deve estar vazio).\n\n```python\nimport os\n\nos.mkdir(\"meudiretorio\")  # Cria o diretório\nos.rmdir(\"meudiretorio\")  # Exclui o diretório\n```\n\n## Renomeando e Excluindo Arquivos\n\nA função `os.rename` é usada para renomear um arquivo, enquanto `os.remove` é usada para excluir um arquivo.\n\n```python\nimport os\n\nos.rename(\"meuarquivo.txt\", \"meuarquivo_novo.txt\")\nos.remove(\"meuarquivo_novo.txt\")\n```\n\n## Outras Funções Úteis do Módulo os\n\n- `os.getcwd()` - retorna o diretório atual\n- `os.chdir(caminho)` - muda o diretório atual\n- `os.listdir(caminho)` - lista arquivos e diretórios\n- `os.path.exists(caminho)` - verifica se um caminho existe\n- `os.path.isfile(caminho)` - verifica se é um arquivo\n- `os.path.isdir(caminho)` - verifica se é um diretório"
          }
        },
        {
          "id": "section-07-02-02",
          "title": "Copiando e Movendo Arquivos",
          "contentType": "text",
          "order": 2,
          "estimatedMinutes": 3,
          "content": {
            "body": "O módulo `shutil` é usado para copiar e mover arquivos em Python. Este módulo oferece operações de alto nível para manipulação de arquivos e coleções de arquivos.\n\n## Copiando Arquivos\n\nA função `shutil.copy` copia um arquivo para outro local:\n\n```python\nimport shutil\n\nshutil.copy(\"meuarquivo.txt\", \"diretorio_novo/meuarquivo.txt\")\n```\n\n## Movendo Arquivos\n\nA função `shutil.move` move um arquivo para outro local (também pode ser usada para renomear):\n\n```python\nimport shutil\n\nshutil.move(\"meuarquivo.txt\", \"diretorio_novo/meuarquivo_novo.txt\")\n```\n\n## Copiando Diretórios\n\nPara copiar um diretório inteiro com todo seu conteúdo, use `shutil.copytree`:\n\n```python\nimport shutil\n\nshutil.copytree(\"diretorio_origem\", \"diretorio_destino\")\n```\n\n## Excluindo Diretórios com Conteúdo\n\nPara excluir um diretório que não está vazio, use `shutil.rmtree`:\n\n```python\nimport shutil\n\nshutil.rmtree(\"diretorio_para_excluir\")\n```\n\n**Atenção**: `rmtree` exclui permanentemente o diretório e todo seu conteúdo. Use com cuidado!"
          }
        },
        {
          "id": "section-07-02-03",
          "title": "Compactando e Descompactando Arquivos",
          "contentType": "text",
          "order": 3,
          "estimatedMinutes": 4,
          "content": {
            "body": "O módulo nativo `zipfile` é usado para compactar e descompactar arquivos em Python.\n\n## Compactando Arquivos\n\nUse a classe `ZipFile` para criar um arquivo compactado:\n\n```python\nimport zipfile\n\n# Compactando 3 arquivos em arquivo.zip\nwith zipfile.ZipFile(\"arquivo.zip\", \"w\", \n    compression=zipfile.ZIP_DEFLATED, \n    compresslevel=9) as meu_zip:\n    meu_zip.write(\"arquivo1.txt\")\n    meu_zip.write(\"arquivo2.jpg\")\n    meu_zip.write(\"arquivo3.mp3\")\n```\n\nOs parâmetros `compression` e `compresslevel` definem o algoritmo e o nível de compressão utilizados.\n\n## Descompactando Arquivos\n\nUse o método `extractall` para descompactar todos os arquivos:\n\n```python\nimport zipfile\n\nwith zipfile.ZipFile(\"arquivo.zip\", \"r\") as meu_zip:\n    meu_zip.extractall(\"diretorio_destino\")\n```\n\n## Listando Conteúdo de um ZIP\n\n```python\nimport zipfile\n\nwith zipfile.ZipFile(\"arquivo.zip\", \"r\") as meu_zip:\n    print(meu_zip.namelist())  # Lista os arquivos no ZIP\n```\n\n## Extraindo Arquivo Específico\n\n```python\nimport zipfile\n\nwith zipfile.ZipFile(\"arquivo.zip\", \"r\") as meu_zip:\n    meu_zip.extract(\"arquivo1.txt\", \"destino/\")\n```"
          }
        },
        {
          "id": "section-07-02-04",
          "title": "O Módulo pathlib: Uma Abordagem Moderna",
          "contentType": "text",
          "order": 4,
          "estimatedMinutes": 6,
          "content": {
            "body": "O módulo `pathlib` oferece uma alternativa mais moderna e orientada a objetos para trabalhar com caminhos de arquivos e diretórios. Introduzido no Python 3.4, o `pathlib` torna operações com caminhos mais intuitivas e menos propensas a erros.\n\n## Comparação com os.path\n\n```python\nimport os\nfrom pathlib import Path\n\n# Abordagem tradicional com os.path\ncaminho_antigo = os.path.join('pasta', 'subpasta', 'arquivo.txt')\nexiste_antigo = os.path.exists(caminho_antigo)\n\n# Abordagem moderna com pathlib\ncaminho_novo = Path('pasta') / 'subpasta' / 'arquivo.txt'\nexiste_novo = caminho_novo.exists()\n```\n\nObserve como o operador `/` torna a construção de caminhos mais natural e legível.\n\n## Lendo e Escrevendo Arquivos com pathlib\n\n```python\nfrom pathlib import Path\n\narquivo = Path('dados.txt')\n\n# Escrever conteúdo\narquivo.write_text('Olá, Python!', encoding='utf-8')\n\n# Ler conteúdo\nconteudo = arquivo.read_text(encoding='utf-8')\nprint(conteudo)  # Saída: Olá, Python!\n```\n\n## Verificando Informações\n\n```python\nfrom pathlib import Path\n\narquivo = Path('meuarquivo.txt')\n\nprint(arquivo.exists())      # Arquivo existe?\nprint(arquivo.is_file())     # É um arquivo?\nprint(arquivo.is_dir())      # É um diretório?\nprint(arquivo.suffix)        # Extensão: '.txt'\nprint(arquivo.stem)          # Nome sem extensão: 'meuarquivo'\nprint(arquivo.name)          # Nome completo: 'meuarquivo.txt'\nprint(arquivo.parent)        # Diretório pai\nprint(arquivo.resolve())     # Caminho absoluto\n```\n\n## Operações com Diretórios\n\n```python\nfrom pathlib import Path\n\n# Criar diretório\nnovo_dir = Path('meu_projeto')\nnovo_dir.mkdir(exist_ok=True)\n\n# Criar diretórios aninhados\nsubdir = Path('meu_projeto/src/modulos')\nsubdir.mkdir(parents=True, exist_ok=True)\n\n# Listar conteúdo\nprojeto = Path('meu_projeto')\nfor item in projeto.iterdir():\n    print(f\"Encontrado: {item.name}\")\n\n# Buscar arquivos por padrão (glob)\narquivos_py = projeto.glob('**/*.py')  # Recursivo\nfor arquivo in arquivos_py:\n    print(f\"Arquivo Python: {arquivo}\")\n```"
          }
        },
        {
          "id": "section-07-02-05",
          "title": "Exercício: Gerenciamento de Arquivos",
          "contentType": "exercise",
          "order": 5,
          "estimatedMinutes": 8,
          "content": {
            "problem": "Crie um programa que:\n\n1. Crie um diretório chamado \"Textos\"\n2. Dentro desse diretório, crie 3 arquivos com os nomes \"arquivo1.txt\", \"arquivo2.txt\" e \"arquivo3.txt\", todos contendo o texto \"Python Essencial\"\n3. Crie um arquivo compactado (.zip) contendo o diretório \"Textos\" com todos os arquivos\n\nUse preferencialmente o módulo pathlib para manipulação de caminhos.",
            "starterCode": "from pathlib import Path\nimport zipfile\n\n# Seu código aqui\n",
            "testCases": [
              {
                "input": "",
                "expectedOutput": "Diretório 'Textos' criado com 3 arquivos e compactado em 'Textos.zip'",
                "description": "Deve criar a estrutura de diretórios e o arquivo ZIP"
              }
            ],
            "hints": [
              "Use Path.mkdir() com exist_ok=True para criar o diretório",
              "Use Path.write_text() para criar os arquivos de texto",
              "Use um loop for para criar os 3 arquivos",
              "Use ZipFile para criar o arquivo compactado"
            ],
            "solution": "from pathlib import Path\nimport zipfile\n\n# Criar diretório\ndiretorio = Path('Textos')\ndiretorio.mkdir(exist_ok=True)\n\n# Criar os 3 arquivos\nfor i in range(1, 4):\n    arquivo = diretorio / f'arquivo{i}.txt'\n    arquivo.write_text('Python Essencial', encoding='utf-8')\n\n# Compactar o diretório\nwith zipfile.ZipFile('Textos.zip', 'w', compression=zipfile.ZIP_DEFLATED) as meu_zip:\n    for arquivo in diretorio.glob('*.txt'):\n        meu_zip.write(arquivo)\n\nprint(\"Diretório 'Textos' criado com 3 arquivos e compactado em 'Textos.zip'\")"
          }
        },
        {
          "id": "section-07-02-06",
          "title": "Quiz: Gerenciamento de Arquivos",
          "contentType": "quiz",
          "order": 6,
          "estimatedMinutes": 3,
          "content": {
            "questions": [
              {
                "id": "q1",
                "question": "Qual módulo Python é usado para copiar e mover arquivos?",
                "options": [
                  "os",
                  "sys",
                  "shutil",
                  "pathlib"
                ],
                "correctAnswer": 2,
                "explanation": "O módulo shutil (shell utilities) fornece funções de alto nível para copiar e mover arquivos e diretórios, como shutil.copy() e shutil.move()."
              },
              {
                "id": "q2",
                "question": "Qual função do módulo os é usada para excluir um arquivo?",
                "options": [
                  "os.delete()",
                  "os.remove()",
                  "os.unlink()",
                  "Ambas b e c estão corretas"
                ],
                "correctAnswer": 3,
                "explanation": "Tanto os.remove() quanto os.unlink() podem ser usadas para excluir arquivos em Python. São funções equivalentes."
              },
              {
                "id": "q3",
                "question": "Qual é a principal vantagem do módulo pathlib sobre os.path?",
                "options": [
                  "É mais rápido",
                  "É orientado a objetos e mais intuitivo",
                  "Funciona apenas em Windows",
                  "Permite apenas operações de leitura"
                ],
                "correctAnswer": 1,
                "explanation": "O pathlib oferece uma API orientada a objetos, tornando o código mais legível e intuitivo. O operador / para concatenar caminhos é um exemplo disso."
              },
              {
                "id": "q4",
                "question": "Como criar um arquivo ZIP com nível máximo de compressão?",
                "options": [
                  "zipfile.ZipFile('arquivo.zip', 'w', compresslevel=9)",
                  "zipfile.ZipFile('arquivo.zip', 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=9)",
                  "zipfile.ZipFile('arquivo.zip', 'w', maxcompression=True)",
                  "zipfile.create('arquivo.zip', level=9)"
                ],
                "correctAnswer": 1,
                "explanation": "Para usar compressão, deve-se especificar o algoritmo (ZIP_DEFLATED) e opcionalmente o nível de compressão (1-9, onde 9 é o máximo)."
              }
            ]
          }
        }
      ]
    },
    {
      "id": "lesson-07-03",
      "title": "Módulos e Pacotes",
      "slug": "modulos-e-pacotes",
      "description": "Aprenda a importar, criar e utilizar módulos e pacotes em Python para organizar e reutilizar código.",
      "order": 3,
      "estimatedMinutes": 22,
      "sections": [
        {
          "id": "section-07-03-01",
          "title": "Importando e Usando Módulos",
          "contentType": "text",
          "order": 1,
          "estimatedMinutes": 4,
          "content": {
            "body": "Um módulo é um arquivo Python que pode conter funções, classes e outros objetos reutilizáveis. Para importar um módulo em Python, usamos a instrução `import`.\n\n## Importando um Módulo Completo\n\n```python\nimport math\n\nresultado = math.sqrt(25)  # Raiz quadrada de 25\nprint(resultado)  # 5.0\n```\n\n## Usando Alias (Apelido)\n\nVocê pode apelidar um módulo ao importá-lo usando a instrução `as`:\n\n```python\nimport math as m\n\nresultado = m.sqrt(25)\nprint(resultado)  # 5.0\n```\n\nIsso permite usar um nome mais curto ao longo do código.\n\n## Importando Itens Específicos\n\nUse a instrução `from` para importar apenas itens específicos de um módulo:\n\n```python\nfrom math import sqrt\n\nresultado = sqrt(25)  # Não precisa do prefixo 'math.'\nprint(resultado)  # 5.0\n```\n\n## Importando Múltiplos Itens\n\n```python\nfrom math import sqrt, pi, floor\n\nprint(sqrt(16))   # 4.0\nprint(pi)         # 3.141592653589793\nprint(floor(3.7)) # 3\n```\n\n## Cuidado com `from module import *`\n\nEvite usar `from module import *` pois isso importa todos os itens do módulo e pode causar conflitos de nomes no seu código."
          }
        },
        {
          "id": "section-07-03-02",
          "title": "Criando seus Próprios Módulos",
          "contentType": "text",
          "order": 2,
          "estimatedMinutes": 4,
          "content": {
            "body": "Além de usar módulos nativos da linguagem Python, você pode criar seus próprios módulos para reutilização em seus programas. Para criar um módulo, basta criar um arquivo Python com as funções, classes e objetos que deseja incluir.\n\n## Exemplo: Criando um Módulo\n\nCrie um arquivo chamado `meumodulo.py`:\n\n```python\n# arquivo meumodulo.py\n\ndef minha_funcao():\n    print(\"Esta é minha função.\")\n\ndef calcular_dobro(numero):\n    return numero * 2\n\nMINHA_CONSTANTE = 42\n```\n\n## Usando o Módulo\n\nEm outro arquivo Python, você pode importar e usar seu módulo:\n\n```python\nimport meumodulo\n\nmeumodulo.minha_funcao()\nresultado = meumodulo.calcular_dobro(5)\nprint(resultado)  # 10\nprint(meumodulo.MINHA_CONSTANTE)  # 42\n```\n\nOu usando `from`:\n\n```python\nfrom meumodulo import minha_funcao, calcular_dobro\n\nminha_funcao()\nprint(calcular_dobro(10))  # 20\n```\n\n## Importante\n\nO arquivo do módulo deve estar no mesmo diretório do arquivo que o importa, ou em um diretório presente no `sys.path` do Python."
          }
        },
        {
          "id": "section-07-03-03",
          "title": "O Padrão if __name__ == '__main__'",
          "contentType": "text",
          "order": 3,
          "estimatedMinutes": 5,
          "content": {
            "body": "Ao criar módulos Python, você frequentemente se depara com uma situação em que o mesmo arquivo pode ser tanto executado diretamente quanto importado por outro módulo. O padrão `if __name__ == \"__main__\"` resolve este problema.\n\n## Como Funciona\n\nQuando um arquivo Python é executado diretamente, a variável `__name__` recebe o valor `\"__main__\"`. Quando é importado, recebe o nome do módulo.\n\n## Problema sem o Padrão\n\n```python\n# arquivo calculos.py\ndef somar(a, b):\n    return a + b\n\n# Código de teste - SEMPRE executa!\nprint(\"Testando:\", somar(5, 3))\n```\n\nQuando alguém importar este módulo, o código de teste será executado automaticamente!\n\n## Solução com o Padrão\n\n```python\n# arquivo calculos.py\ndef somar(a, b):\n    return a + b\n\nif __name__ == \"__main__\":\n    # Só executa quando o arquivo é executado diretamente\n    print(\"Testando:\", somar(5, 3))\n```\n\n## Uso Prático\n\n```python\n# arquivo conversor_temp.py\ndef celsius_para_fahrenheit(celsius):\n    return (celsius * 9/5) + 32\n\ndef fahrenheit_para_celsius(fahrenheit):\n    return (fahrenheit - 32) * 5/9\n\nif __name__ == \"__main__\":\n    # Interface interativa quando executado diretamente\n    print(\"=== Conversor de Temperaturas ===\")\n    temp = float(input(\"Digite a temperatura em Celsius: \"))\n    resultado = celsius_para_fahrenheit(temp)\n    print(f\"{temp} C = {resultado:.2f} F\")\n```\n\nEste arquivo pode ser:\n- **Executado diretamente**: mostra interface interativa\n- **Importado**: disponibiliza apenas as funções"
          }
        },
        {
          "id": "section-07-03-04",
          "title": "Utilizando Pacotes",
          "contentType": "text",
          "order": 4,
          "estimatedMinutes": 4,
          "content": {
            "body": "Um pacote é um diretório que contém um ou mais módulos Python logicamente relacionados. Para que o Python reconheça um diretório como um pacote, ele deve conter um arquivo especial chamado `__init__.py` (pode estar vazio).\n\n## Estrutura de um Pacote\n\n```\nmeupacote/\n    __init__.py\n    meumodulo.py\n    outromodulo.py\n```\n\n## Importando de um Pacote\n\n```python\nimport meupacote.meumodulo\n\nmeupacote.meumodulo.minha_funcao()\n```\n\nOu usando alias:\n\n```python\nimport meupacote.meumodulo as mm\n\nmm.minha_funcao()\n```\n\nOu importando itens específicos:\n\n```python\nfrom meupacote.meumodulo import minha_funcao\n\nminha_funcao()\n```\n\n## Pacotes Aninhados\n\n```\nmeuprojeto/\n    __init__.py\n    utils/\n        __init__.py\n        texto.py\n        numeros.py\n    modelos/\n        __init__.py\n        usuario.py\n```\n\n```python\nfrom meuprojeto.utils.texto import formatar_nome\nfrom meuprojeto.modelos.usuario import Usuario\n```\n\n## O Arquivo __init__.py\n\nO `__init__.py` pode ser usado para:\n- Marcar o diretório como um pacote Python\n- Inicializar variáveis do pacote\n- Definir quais módulos são exportados com `__all__`"
          }
        },
        {
          "id": "section-07-03-05",
          "title": "Exercício: Criando um Módulo",
          "contentType": "exercise",
          "order": 5,
          "estimatedMinutes": 7,
          "content": {
            "problem": "Crie um módulo chamado \"Utils.py\" com uma função chamada `exibir_data_hora` que mostra a data e a hora atuais no terminal no formato \"DD/MM/AAAA HH:MM:SS\".\n\nO módulo deve:\n1. Importar o módulo `datetime`\n2. Ter uma função `exibir_data_hora()` que imprime a data e hora formatadas\n3. Ter uma função `obter_data_hora()` que retorna a data e hora como string\n4. Usar o padrão `if __name__ == \"__main__\"` para testar as funções quando executado diretamente",
            "starterCode": "# arquivo Utils.py\n# Importe o módulo datetime\n\n# Sua implementação aqui\n",
            "testCases": [
              {
                "input": "",
                "expectedOutput": "Data e hora no formato DD/MM/AAAA HH:MM:SS",
                "description": "Deve exibir a data e hora formatadas corretamente"
              }
            ],
            "hints": [
              "Use from datetime import datetime para importar a classe datetime",
              "Use datetime.now() para obter a data e hora atuais",
              "Use strftime(\"%d/%m/%Y %H:%M:%S\") para formatar a data e hora"
            ],
            "solution": "# arquivo Utils.py\nfrom datetime import datetime\n\ndef exibir_data_hora():\n    \"\"\"\n    Exibe a data e hora atuais no formato DD/MM/AAAA HH:MM:SS.\n    \"\"\"\n    agora = datetime.now()\n    print(agora.strftime(\"%d/%m/%Y %H:%M:%S\"))\n\ndef obter_data_hora():\n    \"\"\"\n    Retorna a data e hora atuais como string no formato DD/MM/AAAA HH:MM:SS.\n    \"\"\"\n    agora = datetime.now()\n    return agora.strftime(\"%d/%m/%Y %H:%M:%S\")\n\nif __name__ == \"__main__\":\n    print(\"Testando o módulo Utils:\")\n    exibir_data_hora()\n    print(f\"Retorno da função: {obter_data_hora()}\")"
          }
        },
        {
          "id": "section-07-03-06",
          "title": "Quiz: Módulos e Pacotes",
          "contentType": "quiz",
          "order": 6,
          "estimatedMinutes": 3,
          "content": {
            "questions": [
              {
                "id": "q1",
                "question": "Qual é a forma correta de importar apenas a função sqrt do módulo math?",
                "options": [
                  "import sqrt from math",
                  "from math import sqrt",
                  "import math.sqrt",
                  "include math.sqrt"
                ],
                "correctAnswer": 1,
                "explanation": "A sintaxe correta em Python é 'from modulo import item'. Assim, 'from math import sqrt' importa apenas a função sqrt."
              },
              {
                "id": "q2",
                "question": "Qual arquivo especial deve existir em um diretório para que o Python o reconheça como um pacote?",
                "options": [
                  "__main__.py",
                  "__package__.py",
                  "__init__.py",
                  "setup.py"
                ],
                "correctAnswer": 2,
                "explanation": "O arquivo __init__.py indica ao Python que o diretório deve ser tratado como um pacote. Ele pode estar vazio ou conter código de inicialização."
              },
              {
                "id": "q3",
                "question": "Qual é o valor de __name__ quando um arquivo Python é executado diretamente?",
                "options": [
                  "O nome do arquivo",
                  "\"__main__\"",
                  "None",
                  "\"module\""
                ],
                "correctAnswer": 1,
                "explanation": "Quando um arquivo é executado diretamente, __name__ recebe o valor \"__main__\". Quando é importado, recebe o nome do módulo."
              },
              {
                "id": "q4",
                "question": "Por que devemos evitar usar 'from module import *'?",
                "options": [
                  "É mais lento que outras formas de importação",
                  "Não funciona com todos os módulos",
                  "Pode causar conflitos de nomes no namespace",
                  "Só funciona em Python 2"
                ],
                "correctAnswer": 2,
                "explanation": "Usar 'from module import *' importa todos os nomes públicos do módulo, podendo sobrescrever variáveis existentes e tornando difícil rastrear a origem dos nomes no código."
              }
            ]
          }
        }
      ]
    },
    {
      "id": "lesson-07-04",
      "title": "Documentando Módulos",
      "slug": "documentando-modulos",
      "description": "Aprenda a documentar módulos, funções e classes em Python usando docstrings e ferramentas de documentação.",
      "order": 4,
      "estimatedMinutes": 15,
      "sections": [
        {
          "id": "section-07-04-01",
          "title": "Documentando com Docstrings",
          "contentType": "text",
          "order": 1,
          "estimatedMinutes": 4,
          "content": {
            "body": "A documentação de código é uma parte importante do desenvolvimento de software, ajudando a garantir que o código seja fácil de entender e usar. Em Python, usamos docstrings para documentar módulos, funções e classes.\n\n## O que é uma Docstring?\n\nUma docstring é um comentário textual colocado no início da definição de uma função, classe ou módulo. O texto deve estar entre três aspas duplas.\n\n## Documentando uma Função\n\n```python\ndef dobro(numero):\n    \"\"\"\n    Retorna o dobro de um número.\n\n    Parâmetros:\n    numero (int ou float): O número a ser dobrado.\n\n    Retorno:\n    int ou float: O dobro do número.\n    \"\"\"\n    return numero * 2\n```\n\n## Documentando uma Classe\n\n```python\nclass Calculadora:\n    \"\"\"\n    Uma calculadora simples para operações básicas.\n    \n    Atributos:\n    historico (list): Lista de operações realizadas.\n    \n    Métodos:\n    somar(a, b): Retorna a soma de dois números.\n    subtrair(a, b): Retorna a subtração de dois números.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Inicializa a calculadora com histórico vazio.\"\"\"\n        self.historico = []\n```\n\n## Estilos de Docstring\n\nExistem vários estilos populares:\n- **Google Style**: formatação clara e legível\n- **NumPy Style**: muito usado em bibliotecas científicas\n- **Sphinx Style**: usado para geração automática de documentação"
          }
        },
        {
          "id": "section-07-04-02",
          "title": "Acessando e Gerando Documentação",
          "contentType": "text",
          "order": 2,
          "estimatedMinutes": 4,
          "content": {
            "body": "Python oferece ferramentas integradas para acessar e gerar documentação a partir de docstrings.\n\n## Acessando Docstrings com help()\n\nA função `help()` exibe a documentação de qualquer objeto:\n\n```python\ndef dobro(numero):\n    \"\"\"Retorna o dobro de um número.\"\"\"\n    return numero * 2\n\nhelp(dobro)\n```\n\nSaída:\n```\nHelp on function dobro in module __main__:\n\ndobro(numero)\n    Retorna o dobro de um número.\n```\n\n## Acessando Diretamente o Atributo __doc__\n\n```python\nprint(dobro.__doc__)\n# Saída: Retorna o dobro de um número.\n```\n\n## Gerando Documentação com pydoc\n\nO módulo `pydoc` permite gerar documentação no terminal ou em HTML:\n\n```bash\n# Ver documentação no terminal\npython -m pydoc meumodulo\n\n# Gerar documentação HTML\npython -m pydoc -w meumodulo\n\n# Iniciar servidor de documentação\npython -m pydoc -p 8080\n```\n\n## Ferramentas Avançadas\n\nPara projetos maiores, considere usar:\n- **Sphinx**: gera documentação profissional em vários formatos\n- **MkDocs**: documentação baseada em Markdown\n- **pdoc**: geração automática de documentação"
          }
        },
        {
          "id": "section-07-04-03",
          "title": "Exercício: Documentando Código",
          "contentType": "exercise",
          "order": 3,
          "estimatedMinutes": 5,
          "content": {
            "problem": "Crie um módulo chamado \"formatadores.py\" com duas funções documentadas:\n\n1. `formatar_cpf(cpf)`: Recebe uma string de 11 dígitos e retorna no formato XXX.XXX.XXX-XX\n2. `formatar_telefone(telefone)`: Recebe uma string de 11 dígitos e retorna no formato (XX) XXXXX-XXXX\n\nAmbas as funções devem ter docstrings completas com descrição, parâmetros, retorno e exemplos. Devem também levantar ValueError se o tamanho da string for incorreto.",
            "starterCode": "# arquivo formatadores.py\n\ndef formatar_cpf(cpf):\n    # Sua implementação aqui\n    pass\n\ndef formatar_telefone(telefone):\n    # Sua implementação aqui\n    pass\n\nif __name__ == \"__main__\":\n    # Teste suas funções aqui\n    pass\n",
            "testCases": [
              {
                "input": "formatar_cpf('12345678901')",
                "expectedOutput": "123.456.789-01",
                "description": "Deve formatar CPF corretamente"
              },
              {
                "input": "formatar_telefone('11987654321')",
                "expectedOutput": "(11) 98765-4321",
                "description": "Deve formatar telefone corretamente"
              }
            ],
            "hints": [
              "Use string slicing para separar as partes do CPF e telefone",
              "Use f-strings para formatar a saída",
              "Valide o tamanho da string com len() e levante ValueError se necessário"
            ],
            "solution": "# arquivo formatadores.py\n\ndef formatar_cpf(cpf):\n    \"\"\"\n    Formata uma string de CPF no padrão XXX.XXX.XXX-XX.\n    \n    Parâmetros:\n    cpf (str): String contendo os 11 dígitos do CPF.\n    \n    Retorno:\n    str: CPF formatado.\n    \n    Exceções:\n    ValueError: Se o CPF não tiver 11 dígitos.\n    \n    Exemplo:\n    >>> formatar_cpf('12345678901')\n    '123.456.789-01'\n    \"\"\"\n    if len(cpf) != 11:\n        raise ValueError(\"CPF deve ter 11 dígitos\")\n    return f\"{cpf[:3]}.{cpf[3:6]}.{cpf[6:9]}-{cpf[9:]}\"\n\ndef formatar_telefone(telefone):\n    \"\"\"\n    Formata uma string de telefone no padrão (XX) XXXXX-XXXX.\n    \n    Parâmetros:\n    telefone (str): String contendo os 11 dígitos do telefone.\n    \n    Retorno:\n    str: Telefone formatado.\n    \n    Exceções:\n    ValueError: Se o telefone não tiver 11 dígitos.\n    \n    Exemplo:\n    >>> formatar_telefone('11987654321')\n    '(11) 98765-4321'\n    \"\"\"\n    if len(telefone) != 11:\n        raise ValueError(\"Telefone deve ter 11 dígitos\")\n    return f\"({telefone[:2]}) {telefone[2:7]}-{telefone[7:]}\"\n\nif __name__ == \"__main__\":\n    print(\"Exemplos de formatação:\")\n    print(f\"CPF: {formatar_cpf('12345678901')}\")\n    print(f\"Telefone: {formatar_telefone('11987654321')}\")"
          }
        },
        {
          "id": "section-07-04-04",
          "title": "Quiz: Documentação em Python",
          "contentType": "quiz",
          "order": 4,
          "estimatedMinutes": 2,
          "content": {
            "questions": [
              {
                "id": "q1",
                "question": "Como acessar a docstring de uma função chamada 'calcular'?",
                "options": [
                  "calcular.doc",
                  "calcular.__doc__",
                  "help.calcular",
                  "doc(calcular)"
                ],
                "correctAnswer": 1,
                "explanation": "O atributo __doc__ armazena a docstring de um objeto. Também é possível usar help(calcular) para visualizar a documentação formatada."
              },
              {
                "id": "q2",
                "question": "Qual comando gera documentação HTML de um módulo usando pydoc?",
                "options": [
                  "python -m pydoc --html meumodulo",
                  "python -m pydoc -w meumodulo",
                  "python -m pydoc -o meumodulo.html meumodulo",
                  "pydoc.generate(meumodulo)"
                ],
                "correctAnswer": 1,
                "explanation": "O comando 'python -m pydoc -w meumodulo' gera um arquivo HTML com a documentação do módulo especificado."
              },
              {
                "id": "q3",
                "question": "Onde deve ser colocada a docstring de uma função?",
                "options": [
                  "Antes da definição da função",
                  "Logo após a linha 'def nome_funcao():'",
                  "Ao final da função",
                  "Em um arquivo separado"
                ],
                "correctAnswer": 1,
                "explanation": "A docstring deve ser a primeira instrução após a definição da função (logo após a linha 'def'), entre três aspas duplas."
              }
            ]
          }
        }
      ]
    },
    {
      "id": "lesson-07-05",
      "title": "Gerenciando Dependências com pip",
      "slug": "gerenciando-dependencias-pip",
      "description": "Aprenda a instalar, atualizar e gerenciar pacotes Python usando pip e arquivos requirements.txt.",
      "order": 5,
      "estimatedMinutes": 18,
      "sections": [
        {
          "id": "section-07-05-01",
          "title": "Instalando e Atualizando Pacotes",
          "contentType": "text",
          "order": 1,
          "estimatedMinutes": 4,
          "content": {
            "body": "Ao desenvolver projetos em Python, é comum depender de módulos externos que fornecem funcionalidades adicionais. O `pip` é o gerenciador de pacotes mais popular para Python.\n\n## Instalando Pacotes\n\nPara instalar um pacote, use o comando `pip install`:\n\n```bash\npip install numpy\n```\n\nIsso baixa e instala a versão mais recente do pacote `numpy`.\n\n## Instalando uma Versão Específica\n\n```bash\npip install numpy==1.26.0\n```\n\n## Instalando Múltiplos Pacotes\n\n```bash\npip install numpy pandas matplotlib\n```\n\n## Atualizando Pacotes\n\nPara atualizar um pacote para a versão mais recente:\n\n```bash\npip install numpy --upgrade\n```\n\nOu de forma abreviada:\n\n```bash\npip install -U numpy\n```\n\n## Desinstalando Pacotes\n\n```bash\npip uninstall numpy\n```\n\n## Listando Pacotes Instalados\n\n```bash\npip list\n```\n\n## Verificando Informações de um Pacote\n\n```bash\npip show numpy\n```\n\nIsso exibe versão, localização, dependências e outras informações do pacote."
          }
        },
        {
          "id": "section-07-05-02",
          "title": "Gerenciando Versões com requirements.txt",
          "contentType": "text",
          "order": 2,
          "estimatedMinutes": 4,
          "content": {
            "body": "Para gerenciar as versões de pacotes em seus projetos, é recomendado usar um arquivo `requirements.txt` que lista todas as dependências do projeto.\n\n## Formato do requirements.txt\n\n```\nnumpy==1.26.0\nfastapi==0.110.0\nrequests==2.31.0\npandas>=2.0.0\nmatplotlib>=3.7.0,<4.0.0\n```\n\n## Operadores de Versão\n\n- `==` - versão exata\n- `>=` - versão mínima\n- `<=` - versão máxima\n- `>` e `<` - maior/menor que\n- `~=` - versão compatível (ex: `~=1.4.0` aceita 1.4.x mas não 1.5.0)\n\n## Instalando Dependências do requirements.txt\n\n```bash\npip install -r requirements.txt\n```\n\n## Gerando requirements.txt\n\nPara gerar um arquivo com todas as dependências instaladas no ambiente atual:\n\n```bash\npip freeze > requirements.txt\n```\n\n**Atenção**: `pip freeze` lista TODOS os pacotes instalados. Em ambientes virtuais, isso é ideal. Em instalações globais, pode incluir pacotes desnecessários.\n\n## Boas Práticas\n\n1. Sempre especifique versões exatas em produção\n2. Use ambientes virtuais para isolar dependências\n3. Mantenha o requirements.txt atualizado\n4. Documente dependências de desenvolvimento separadamente (ex: `requirements-dev.txt`)"
          }
        },
        {
          "id": "section-07-05-03",
          "title": "Ambientes Virtuais com venv",
          "contentType": "text",
          "order": 3,
          "estimatedMinutes": 5,
          "content": {
            "body": "Um ambiente virtual é uma instância isolada do interpretador Python que permite executar aplicações e instalar bibliotecas sem interferir nas demais instalações do sistema.\n\n## Criando um Ambiente Virtual\n\nUse o módulo `venv` para criar um ambiente virtual:\n\n```bash\npython3 -m venv meu_ambiente\n```\n\nIsso cria um diretório `meu_ambiente` com uma cópia do interpretador Python e o pip.\n\n## Ativando o Ambiente Virtual\n\n**No Windows:**\n```bash\ncd meu_ambiente\\Scripts\nactivate\n```\n\n**No Linux/macOS:**\n```bash\nsource meu_ambiente/bin/activate\n```\n\nApós a ativação, o nome do ambiente aparece entre parênteses no terminal:\n```\n(meu_ambiente) $ _\n```\n\n## Instalando Pacotes no Ambiente Virtual\n\nCom o ambiente ativado, qualquer pacote instalado fica restrito a esse ambiente:\n\n```bash\npip install requests\n```\n\n## Desativando o Ambiente Virtual\n\n```bash\ndeactivate\n```\n\n## Vantagens dos Ambientes Virtuais\n\n1. **Isolamento**: Cada projeto pode ter suas próprias dependências\n2. **Versões diferentes**: Projetos podem usar versões diferentes do mesmo pacote\n3. **Reproducibilidade**: Facilita reproduzir o ambiente em outras máquinas\n4. **Limpeza**: Fácil de excluir (basta apagar o diretório)\n\n## Fluxo de Trabalho Recomendado\n\n```bash\n# Criar ambiente\npython3 -m venv venv\n\n# Ativar ambiente\nsource venv/bin/activate  # ou venv\\Scripts\\activate no Windows\n\n# Instalar dependências\npip install -r requirements.txt\n\n# Trabalhar no projeto...\n\n# Desativar quando terminar\ndeactivate\n```"
          }
        },
        {
          "id": "section-07-05-04",
          "title": "Exercício: Gerenciando Dependências",
          "contentType": "exercise",
          "order": 4,
          "estimatedMinutes": 5,
          "content": {
            "problem": "Execute os seguintes passos de gerenciamento de dependências:\n\n1. Crie um novo ambiente virtual chamado \"pratica_venv\"\n2. Ative o ambiente virtual\n3. Instale a biblioteca `requests` usando pip\n4. Verifique se a biblioteca foi instalada corretamente\n5. Crie um arquivo requirements.txt com as dependências\n6. Desative o ambiente virtual\n\nDocumente cada comando utilizado.",
            "starterCode": "# Comandos a serem executados no terminal:\n\n# 1. Criar ambiente virtual\n# Seu comando aqui\n\n# 2. Ativar ambiente virtual\n# Seu comando aqui\n\n# 3. Instalar requests\n# Seu comando aqui\n\n# 4. Verificar instalação\n# Seu comando aqui\n\n# 5. Criar requirements.txt\n# Seu comando aqui\n\n# 6. Desativar ambiente\n# Seu comando aqui\n",
            "testCases": [
              {
                "input": "",
                "expectedOutput": "Ambiente virtual criado e configurado com sucesso",
                "description": "Todos os comandos devem executar sem erros"
              }
            ],
            "hints": [
              "Use 'python3 -m venv nome_ambiente' para criar o ambiente",
              "No Linux/macOS use 'source' para ativar, no Windows use o caminho completo",
              "Use 'pip list' ou 'pip show requests' para verificar a instalação",
              "Use 'pip freeze > requirements.txt' para gerar o arquivo de dependências"
            ],
            "solution": "# Comandos a serem executados no terminal:\n\n# 1. Criar ambiente virtual\npython3 -m venv pratica_venv\n\n# 2. Ativar ambiente virtual\n# No Linux/macOS:\nsource pratica_venv/bin/activate\n# No Windows:\n# pratica_venv\\Scripts\\activate\n\n# 3. Instalar requests\npip install requests\n\n# 4. Verificar instalação\npip show requests\n# ou\npip list\n\n# 5. Criar requirements.txt\npip freeze > requirements.txt\n\n# 6. Desativar ambiente\ndeactivate"
          }
        },
        {
          "id": "section-07-05-05",
          "title": "Quiz: Gerenciamento de Pacotes",
          "contentType": "quiz",
          "order": 5,
          "estimatedMinutes": 3,
          "content": {
            "questions": [
              {
                "id": "q1",
                "question": "Qual comando instala um pacote Python usando pip?",
                "options": [
                  "pip download pacote",
                  "pip add pacote",
                  "pip install pacote",
                  "pip get pacote"
                ],
                "correctAnswer": 2,
                "explanation": "O comando 'pip install pacote' é usado para instalar pacotes Python do PyPI (Python Package Index)."
              },
              {
                "id": "q2",
                "question": "Qual comando atualiza um pacote para a versão mais recente?",
                "options": [
                  "pip update pacote",
                  "pip install pacote --upgrade",
                  "pip refresh pacote",
                  "pip upgrade pacote"
                ],
                "correctAnswer": 1,
                "explanation": "O comando 'pip install pacote --upgrade' (ou -U) atualiza o pacote para a versão mais recente disponível."
              },
              {
                "id": "q3",
                "question": "Qual é a principal vantagem de usar ambientes virtuais?",
                "options": [
                  "Aumenta a velocidade de execução do Python",
                  "Permite usar Python sem instalar",
                  "Isola as dependências de cada projeto",
                  "Permite rodar código malicioso com segurança"
                ],
                "correctAnswer": 2,
                "explanation": "Ambientes virtuais isolam as dependências de cada projeto, permitindo que diferentes projetos usem versões diferentes dos mesmos pacotes sem conflitos."
              },
              {
                "id": "q4",
                "question": "Qual comando cria um arquivo com todas as dependências instaladas no ambiente atual?",
                "options": [
                  "pip list > requirements.txt",
                  "pip freeze > requirements.txt",
                  "pip export > requirements.txt",
                  "pip save > requirements.txt"
                ],
                "correctAnswer": 1,
                "explanation": "O comando 'pip freeze' lista todos os pacotes instalados com suas versões exatas, e o operador '>' redireciona a saída para um arquivo."
              },
              {
                "id": "q5",
                "question": "Como instalar todas as dependências listadas em um arquivo requirements.txt?",
                "options": [
                  "pip install requirements.txt",
                  "pip install -r requirements.txt",
                  "pip load requirements.txt",
                  "pip import -f requirements.txt"
                ],
                "correctAnswer": 1,
                "explanation": "O comando 'pip install -r requirements.txt' lê o arquivo e instala todos os pacotes listados com suas versões especificadas."
              }
            ]
          }
        }
      ]
    }
  ]
}

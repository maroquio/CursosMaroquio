{
  "module": {
    "title": "Coleções",
    "description": "A linguagem Python possui quatro tipos de coleções: listas, tuplas, dicionários e conjuntos. Neste módulo, são apresentadas técnicas avançadas e eficientes para manipulação de coleções em Python.",
    "order": 6
  },
  "lessons": [
    {
      "title": "Indexação de Coleções",
      "slug": "indexacao-de-colecoes",
      "description": "Aprenda a acessar elementos individuais e intervalos em coleções Python usando indexação e fatiamento.",
      "order": 1,
      "duration": 900,
      "sections": [
        {
          "title": "Introdução à Indexação",
          "contentType": "text",
          "order": 1,
          "content": "## Indexação em Python\n\nEm Python, a **indexação** é uma operação que permite acessar elementos individuais ou intervalos de elementos de uma coleção. As coleções Python incluem listas, tuplas, dicionários, conjuntos e também *strings*, que são consideradas coleções de caracteres.\n\n### Acessando um Único Elemento\n\nPara acessar um único elemento de uma coleção, use o índice numérico correspondente à posição do elemento. Lembre-se:\n\n- O índice do primeiro elemento é **0**\n- O índice do último elemento é o tamanho da coleção menos 1\n- Índices negativos permitem navegar do fim para o início (-1 é o último, -2 o penúltimo, etc.)\n\n```python\n# Acessando um elemento único em uma lista\nlista = [1, 2, 3, 4, 5]\nprint(lista[0])  # Saída: 1\nprint(lista[2])  # Saída: 3\n\n# Acessando um caractere único em uma string\nfrase = \"Olá, Python!\"\nprint(frase[0])  # Saída: O\nprint(frase[-1])  # Saída: !\n```\n\nEste exemplo demonstra que as listas em Python são indexadas a partir de 0 e que índices negativos acessam elementos a partir do final da sequência."
        },
        {
          "title": "Fatiamento (Slicing)",
          "contentType": "text",
          "order": 2,
          "content": "## Fatiamento de Coleções\n\nPara acessar um **intervalo de elementos** dentro de uma coleção, use a sintaxe de fatiamento (*slicing*). O fatiamento usa dois pontos (`:`) entre os índices de início e fim.\n\n**Importante:** O índice final é excludente - se os parâmetros são `0:10`, abrangem os elementos de 0 a 9.\n\n```python\n# Acessando um intervalo de elementos em uma lista\nlista = [1, 2, 3, 4, 5]\nprint(lista[0:3])  # Saída: [1, 2, 3]\nprint(lista[1:4])  # Saída: [2, 3, 4]\n\n# Acessando um intervalo de caracteres em uma string\nfrase = \"Olá, Python!\"\nprint(frase[0:3])  # Saída: Olá\nprint(frase[5:11])  # Saída: Python\n```\n\n### Acessando Elementos com Passo\n\nVocê pode usar um terceiro parâmetro para indicar o **passo** (salto entre elementos):\n\n```python\n# Acessando elementos de uma lista com passo 2\nlista = [1, 2, 3, 4, 5]\nprint(lista[0:5:2])  # Saída: [1, 3, 5]\n\n# Acessando caracteres de uma string com passo 2\nfrase = \"Olá, Python!\"\nprint(frase[0:12:2])  # Saída: Oá yhn\n```\n\nO passo permite acessar elementos de forma não contínua, extraindo elementos alternados."
        },
        {
          "title": "Índices Negativos e Inversão",
          "contentType": "text",
          "order": 3,
          "content": "## Índices Negativos\n\nÍndices negativos permitem acessar elementos a partir do final da coleção sem calcular explicitamente seus índices positivos:\n\n```python\n# Acessando elementos a partir do final de uma lista\nlista = [1, 2, 3, 4, 5]\nprint(lista[-1])  # Saída: 5\nprint(lista[-2])  # Saída: 4\n\n# Acessando caracteres a partir do final de uma string\nfrase = \"Olá, Python!\"\nprint(frase[-1])  # Saída: !\nprint(frase[-2])  # Saída: n\n```\n\n## Invertendo Coleções\n\nPara inverter todos os elementos de uma coleção, use fatiamento com passo negativo `-1`:\n\n```python\n# Invertendo uma lista\nlista = [1, 2, 3, 4, 5]\nprint(lista[::-1])  # Saída: [5, 4, 3, 2, 1]\n\n# Invertendo uma string\nfrase = \"Olá, Python!\"\nprint(frase[::-1])  # Saída: !nohtyP ,álO\n```\n\nQuando passamos o primeiro índice vazio, indicamos acesso desde o início. O segundo índice vazio indica acesso até o último elemento. O passo `-1` indica acesso do final para o início."
        },
        {
          "title": "Exercício: Manipulação de Índices",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Dada uma lista de números, crie uma função que retorne uma nova lista contendo apenas os elementos de índices pares, em ordem inversa.\n\nExemplo:\n- Entrada: `[10, 20, 30, 40, 50, 60]`\n- Saída: `[50, 30, 10]` (índices 0, 2, 4 invertidos)",
            "starterCode": "def elementos_pares_invertidos(lista):\n    # Seu código aqui\n    pass\n\n# Teste\nnumeros = [10, 20, 30, 40, 50, 60]\nresultado = elementos_pares_invertidos(numeros)\nprint(resultado)",
            "testCases": [
              {
                "input": "[10, 20, 30, 40, 50, 60]",
                "expected": "[50, 30, 10]"
              },
              {
                "input": "[1, 2, 3, 4, 5]",
                "expected": "[5, 3, 1]"
              },
              {
                "input": "[100]",
                "expected": "[100]"
              }
            ],
            "hints": [
              "Use fatiamento com passo 2 para pegar índices pares: lista[::2]",
              "Use [::-1] para inverter o resultado"
            ],
            "solution": "def elementos_pares_invertidos(lista):\n    return lista[::2][::-1]\n\n# Ou em uma única operação de slice:\n# return lista[-2::-2] se o tamanho for par, ou lista[-1::-2] se ímpar"
          }
        },
        {
          "title": "Quiz: Indexação",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "Qual é o resultado de `lista = [1, 2, 3, 4, 5]; print(lista[1:4])`?",
                "options": ["[1, 2, 3]", "[2, 3, 4]", "[2, 3, 4, 5]", "[1, 2, 3, 4]"],
                "correctAnswer": 1,
                "explanation": "O fatiamento [1:4] retorna elementos dos índices 1, 2 e 3 (o índice final é excludente)."
              },
              {
                "question": "O que `frase[-1]` retorna se `frase = \"Python\"`?",
                "options": ["P", "n", "o", "Erro"],
                "correctAnswer": 1,
                "explanation": "O índice -1 acessa o último caractere da string, que é 'n'."
              },
              {
                "question": "Qual é o resultado de `[1, 2, 3, 4, 5][::2]`?",
                "options": ["[2, 4]", "[1, 3, 5]", "[1, 2]", "[3, 4, 5]"],
                "correctAnswer": 1,
                "explanation": "O passo 2 seleciona elementos alternados começando do índice 0: 1, 3, 5."
              },
              {
                "question": "Como inverter uma lista `numeros` usando fatiamento?",
                "options": ["numeros.reverse()", "numeros[::-1]", "numeros[-1:0]", "numeros[0:-1:-1]"],
                "correctAnswer": 1,
                "explanation": "O fatiamento [::-1] com passo negativo inverte a ordem dos elementos."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Métodos de Listas",
      "slug": "metodos-de-listas",
      "description": "Conheça os métodos nativos para manipulação de listas em Python.",
      "order": 2,
      "duration": 840,
      "sections": [
        {
          "title": "Adicionando Elementos",
          "contentType": "text",
          "order": 1,
          "content": "## Métodos para Adicionar Elementos em Listas\n\nAs listas em Python possuem diversos métodos nativos que facilitam sua manipulação.\n\n### append()\n\nO método `append` adiciona um elemento ao **final** da lista:\n\n```python\nfrutas = [\"maçã\", \"banana\"]\nfrutas.append(\"laranja\")\nprint(frutas)  # Saída: ['maçã', 'banana', 'laranja']\n```\n\nO `append` modifica a lista original e não cria uma nova lista.\n\n### extend()\n\nPara adicionar **múltiplos elementos** de uma vez, use `extend`:\n\n```python\nnumeros = [1, 2, 3]\nnumeros.extend([4, 5, 6])\nprint(numeros)  # Saída: [1, 2, 3, 4, 5, 6]\n\n# Comparando com append (adiciona a lista inteira como um elemento)\nnumeros2 = [1, 2, 3]\nnumeros2.append([4, 5, 6])\nprint(numeros2)  # Saída: [1, 2, 3, [4, 5, 6]]\n```\n\n### insert()\n\nPara inserir um elemento em uma **posição específica**, use `insert`:\n\n```python\ncores = [\"vermelho\", \"azul\", \"verde\"]\ncores.insert(1, \"amarelo\")\nprint(cores)  # Saída: ['vermelho', 'amarelo', 'azul', 'verde']\n```\n\nO elemento \"azul\" que estava na posição 1 passa para a posição 2."
        },
        {
          "title": "Removendo Elementos",
          "contentType": "text",
          "order": 2,
          "content": "## Métodos para Remover Elementos\n\n### remove()\n\nO método `remove` elimina a **primeira ocorrência** de um valor específico:\n\n```python\nanimais = [\"gato\", \"cachorro\", \"papagaio\", \"gato\"]\nanimais.remove(\"gato\")\nprint(animais)  # Saída: ['cachorro', 'papagaio', 'gato']\n```\n\n### pop()\n\nO método `pop` remove e **retorna** um elemento por índice:\n\n```python\nanimais = [\"cachorro\", \"papagaio\", \"gato\"]\n\n# Remove e retorna o último elemento\nultimo = animais.pop()\nprint(ultimo)   # Saída: gato\nprint(animais)  # Saída: ['cachorro', 'papagaio']\n\n# Remove e retorna o elemento do índice 0\nprimeiro = animais.pop(0)\nprint(primeiro)  # Saída: cachorro\n```\n\n### clear()\n\nPara esvaziar completamente uma lista:\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nnumeros.clear()\nprint(numeros)  # Saída: []\n```"
        },
        {
          "title": "Buscando e Ordenando",
          "contentType": "text",
          "order": 3,
          "content": "## Métodos de Busca e Ordenação\n\n### index()\n\nDescobre a posição de um elemento:\n\n```python\nletras = [\"a\", \"b\", \"c\", \"b\", \"d\"]\nposicao = letras.index(\"b\")\nprint(posicao)  # Saída: 1\n\n# Busca a partir de um índice específico\nposicao2 = letras.index(\"b\", 2)\nprint(posicao2)  # Saída: 3\n```\n\n### count()\n\nConta quantas vezes um valor aparece:\n\n```python\nnumeros = [1, 2, 3, 2, 4, 2, 5]\nquantidade = numeros.count(2)\nprint(quantidade)  # Saída: 3\n```\n\n### sort() e reverse()\n\n```python\nnumeros = [3, 1, 4, 1, 5, 9, 2]\nnumeros.sort()\nprint(numeros)  # Saída: [1, 1, 2, 3, 4, 5, 9]\n\n# Ordenar em ordem decrescente\nnumeros.sort(reverse=True)\nprint(numeros)  # Saída: [9, 5, 4, 3, 2, 1, 1]\n\n# Inverter a ordem (não ordena, apenas inverte)\nnumeros.reverse()\nprint(numeros)  # Saída: [1, 1, 2, 3, 4, 5, 9]\n```\n\n### copy()\n\nCria uma cópia independente:\n\n```python\noriginal = [1, 2, 3]\nreferencia = original  # Apenas nova referência\ncopia = original.copy()  # Cópia independente\n\noriginal.append(4)\nprint(referencia)  # Saída: [1, 2, 3, 4]\nprint(copia)       # Saída: [1, 2, 3]\n```"
        },
        {
          "title": "Exercício: Métodos de Listas",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Crie uma função que receba uma lista de números e retorne uma nova lista contendo apenas os números que aparecem mais de uma vez, ordenados em ordem crescente.\n\nExemplo:\n- Entrada: `[1, 2, 3, 2, 4, 3, 5, 2]`\n- Saída: `[2, 3]`",
            "starterCode": "def duplicados_ordenados(lista):\n    # Seu código aqui\n    pass\n\n# Teste\nnumeros = [1, 2, 3, 2, 4, 3, 5, 2]\nprint(duplicados_ordenados(numeros))",
            "testCases": [
              {
                "input": "[1, 2, 3, 2, 4, 3, 5, 2]",
                "expected": "[2, 3]"
              },
              {
                "input": "[1, 1, 1, 2, 2, 3]",
                "expected": "[1, 2]"
              },
              {
                "input": "[1, 2, 3, 4, 5]",
                "expected": "[]"
              }
            ],
            "hints": [
              "Use o método count() para verificar quantas vezes cada número aparece",
              "Use um conjunto (set) para evitar duplicatas no resultado",
              "Converta para lista e use sort() para ordenar"
            ],
            "solution": "def duplicados_ordenados(lista):\n    duplicados = set()\n    for num in lista:\n        if lista.count(num) > 1:\n            duplicados.add(num)\n    resultado = list(duplicados)\n    resultado.sort()\n    return resultado"
          }
        },
        {
          "title": "Quiz: Métodos de Listas",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "Qual a diferença entre `append([1,2])` e `extend([1,2])`?",
                "options": [
                  "Não há diferença",
                  "append adiciona a lista como um elemento; extend adiciona cada elemento",
                  "extend adiciona a lista como um elemento; append adiciona cada elemento",
                  "append só funciona com números"
                ],
                "correctAnswer": 1,
                "explanation": "append adiciona o argumento inteiro como um único elemento, enquanto extend adiciona cada elemento individualmente."
              },
              {
                "question": "O que acontece ao chamar `lista.pop()` sem argumentos?",
                "options": [
                  "Remove o primeiro elemento",
                  "Remove e retorna o último elemento",
                  "Gera um erro",
                  "Remove todos os elementos"
                ],
                "correctAnswer": 1,
                "explanation": "Sem argumentos, pop() remove e retorna o último elemento da lista."
              },
              {
                "question": "Por que usar `lista.copy()` em vez de `nova = lista`?",
                "options": [
                  "copy() é mais rápido",
                  "copy() cria uma cópia independente; atribuição cria apenas uma referência",
                  "Não há diferença prática",
                  "Atribuição não funciona com listas"
                ],
                "correctAnswer": 1,
                "explanation": "A atribuição cria uma nova referência para a mesma lista. copy() cria uma lista independente."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Métodos de Dicionários e Conjuntos",
      "slug": "metodos-dicionarios-conjuntos",
      "description": "Aprenda a manipular dicionários e conjuntos com seus métodos nativos.",
      "order": 3,
      "duration": 900,
      "sections": [
        {
          "title": "Métodos de Dicionários",
          "contentType": "text",
          "order": 1,
          "content": "## Métodos de Dicionários\n\n### get()\n\nForma segura de acessar valores, retornando um valor padrão se a chave não existir:\n\n```python\naluno = {\"nome\": \"João\", \"idade\": 20}\n\n# Usando colchetes (gera erro se a chave não existir)\n# print(aluno[\"nota\"])  # Erro: KeyError\n\n# Usando get (retorna None se não existir)\nnota = aluno.get(\"nota\")\nprint(nota)  # Saída: None\n\n# Especificando um valor padrão\nnota = aluno.get(\"nota\", 0)\nprint(nota)  # Saída: 0\n```\n\n### setdefault()\n\nRetorna o valor se a chave existir, ou insere e retorna o padrão:\n\n```python\ncontador = {}\ncontador.setdefault(\"palavras\", 0)\nprint(contador)  # Saída: {'palavras': 0}\n\n# Se a chave já existe, apenas retorna seu valor\ncontador[\"palavras\"] = 5\nresultado = contador.setdefault(\"palavras\", 0)\nprint(resultado)  # Saída: 5\n```\n\n### keys(), values(), items()\n\n```python\nnotas = {\"João\": 8.5, \"Maria\": 9.0, \"Pedro\": 7.5}\n\nfor nome in notas.keys():\n    print(nome)  # João, Maria, Pedro\n\nfor nota in notas.values():\n    print(nota)  # 8.5, 9.0, 7.5\n\nfor nome, nota in notas.items():\n    print(f\"{nome}: {nota}\")\n```"
        },
        {
          "title": "Mais Métodos de Dicionários",
          "contentType": "text",
          "order": 2,
          "content": "## Atualizando e Removendo\n\n### update()\n\nMescla outro dicionário, atualizando chaves existentes e adicionando novas:\n\n```python\nusuario = {\"nome\": \"Ana\", \"idade\": 25}\nnovos_dados = {\"cidade\": \"São Paulo\", \"idade\": 26}\n\nusuario.update(novos_dados)\nprint(usuario)\n# Saída: {'nome': 'Ana', 'idade': 26, 'cidade': 'São Paulo'}\n```\n\n### pop() e popitem()\n\n```python\nproduto = {\"nome\": \"Mouse\", \"preco\": 45.90, \"estoque\": 10}\n\n# Remove e retorna o valor de uma chave específica\npreco = produto.pop(\"preco\")\nprint(preco)     # Saída: 45.90\nprint(produto)   # Saída: {'nome': 'Mouse', 'estoque': 10}\n\n# Remove e retorna o último par inserido (LIFO)\nitem = produto.popitem()\nprint(item)      # Saída: ('estoque', 10)\nprint(produto)   # Saída: {'nome': 'Mouse'}\n```\n\n### clear()\n\n```python\nconfiguracao = {\"tema\": \"escuro\", \"idioma\": \"pt-BR\"}\nconfiguracao.clear()\nprint(configuracao)  # Saída: {}\n```"
        },
        {
          "title": "Métodos de Conjuntos",
          "contentType": "text",
          "order": 3,
          "content": "## Métodos de Conjuntos (Sets)\n\nConjuntos são coleções **não ordenadas** de elementos **únicos**.\n\n### add() e Remoção\n\n```python\nfrutas = {\"maçã\", \"banana\"}\nfrutas.add(\"laranja\")\nprint(frutas)  # Saída: {'banana', 'maçã', 'laranja'}\n\n# Adicionar duplicado não altera o conjunto\nfrutas.add(\"maçã\")\nprint(frutas)  # Saída: {'banana', 'maçã', 'laranja'}\n```\n\n### remove(), discard() e pop()\n\n```python\nnumeros = {1, 2, 3, 4, 5}\n\n# remove: gera erro se não existir\nnumeros.remove(3)\n\n# discard: não gera erro se não existir\nnumeros.discard(10)  # Não faz nada\n\n# pop: remove e retorna elemento arbitrário\nelemento = numeros.pop()\n```\n\n### Operações de Conjuntos\n\n```python\na = {1, 2, 3, 4}\nb = {3, 4, 5, 6}\n\nprint(a | b)  # União: {1, 2, 3, 4, 5, 6}\nprint(a & b)  # Interseção: {3, 4}\nprint(a - b)  # Diferença: {1, 2}\nprint(a ^ b)  # Diferença simétrica: {1, 2, 5, 6}\n```\n\n### Verificando Relações\n\n```python\nvogais = {\"a\", \"e\", \"i\", \"o\", \"u\"}\nalgumas_vogais = {\"a\", \"e\"}\n\nprint(algumas_vogais.issubset(vogais))  # True\nprint(vogais.issuperset(algumas_vogais))  # True\nprint(vogais.isdisjoint({\"b\", \"c\"}))  # True\n```"
        },
        {
          "title": "Exercício: Dicionários e Conjuntos",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Crie uma função que receba duas listas de nomes e retorne um dicionário com:\n- 'ambas': conjunto de nomes que aparecem em ambas as listas\n- 'apenas_primeira': conjunto de nomes apenas na primeira lista\n- 'apenas_segunda': conjunto de nomes apenas na segunda lista\n\nExemplo:\n- lista1: `['Ana', 'Bruno', 'Carlos']`\n- lista2: `['Bruno', 'Diana', 'Carlos']`\n- Saída: `{'ambas': {'Bruno', 'Carlos'}, 'apenas_primeira': {'Ana'}, 'apenas_segunda': {'Diana'}}`",
            "starterCode": "def comparar_listas(lista1, lista2):\n    # Seu código aqui\n    pass\n\n# Teste\nl1 = ['Ana', 'Bruno', 'Carlos']\nl2 = ['Bruno', 'Diana', 'Carlos']\nprint(comparar_listas(l1, l2))",
            "testCases": [
              {
                "input": "['Ana', 'Bruno', 'Carlos'], ['Bruno', 'Diana', 'Carlos']",
                "expected": "{'ambas': {'Bruno', 'Carlos'}, 'apenas_primeira': {'Ana'}, 'apenas_segunda': {'Diana'}}"
              },
              {
                "input": "['A', 'B'], ['C', 'D']",
                "expected": "{'ambas': set(), 'apenas_primeira': {'A', 'B'}, 'apenas_segunda': {'C', 'D'}}"
              }
            ],
            "hints": [
              "Converta as listas em conjuntos para usar operações de conjuntos",
              "Use & para interseção e - para diferença"
            ],
            "solution": "def comparar_listas(lista1, lista2):\n    set1 = set(lista1)\n    set2 = set(lista2)\n    return {\n        'ambas': set1 & set2,\n        'apenas_primeira': set1 - set2,\n        'apenas_segunda': set2 - set1\n    }"
          }
        },
        {
          "title": "Quiz: Dicionários e Conjuntos",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "Qual a vantagem de usar `dict.get('chave', 0)` em vez de `dict['chave']`?",
                "options": [
                  "É mais rápido",
                  "Retorna um valor padrão se a chave não existir, evitando KeyError",
                  "Funciona apenas com números",
                  "Não há vantagem"
                ],
                "correctAnswer": 1,
                "explanation": "get() permite especificar um valor padrão, evitando KeyError quando a chave não existe."
              },
              {
                "question": "O que `{1, 2, 3} & {2, 3, 4}` retorna?",
                "options": ["{1, 2, 3, 4}", "{2, 3}", "{1, 4}", "Erro"],
                "correctAnswer": 1,
                "explanation": "O operador & retorna a interseção dos conjuntos (elementos comuns)."
              },
              {
                "question": "Qual a diferença entre `remove()` e `discard()` em conjuntos?",
                "options": [
                  "Não há diferença",
                  "remove gera erro se elemento não existir; discard não gera erro",
                  "discard gera erro se elemento não existir; remove não gera erro",
                  "remove é mais rápido"
                ],
                "correctAnswer": 1,
                "explanation": "remove() levanta KeyError se o elemento não existir, enquanto discard() simplesmente não faz nada."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Mapeamento e Filtragem",
      "slug": "mapeamento-e-filtragem",
      "description": "Aprenda a usar as funções map e filter para transformar e filtrar coleções.",
      "order": 4,
      "duration": 720,
      "sections": [
        {
          "title": "A Função map()",
          "contentType": "text",
          "order": 1,
          "content": "## Mapeamento com map()\n\nA função `map` aplica uma função a cada elemento de uma coleção, retornando uma nova coleção com os resultados.\n\n### Usando com Lambda\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nquadrados = list(map(lambda x: x**2, numeros))\nprint(quadrados)  # Saída: [1, 4, 9, 16, 25]\n```\n\nO `map` retorna um objeto iterador, por isso usamos `list()` para obter a lista resultante.\n\n### Usando com Função Normal\n\nPara processamentos mais complexos, use uma função normal:\n\n```python\ndef processar(x):\n    passo1 = x**2\n    passo2 = passo1 * 3\n    passo3 = passo2**(1/2)\n    return passo3\n\nnumeros = [1, 2, 3, 4, 5]\nprocessados = list(map(processar, numeros))\nprint(processados)  # Saída: [1.73, 3.46, 5.20, 6.93, 8.67]\n```\n\nA função passada para `map` deve ter um único parâmetro, que receberá cada elemento da lista."
        },
        {
          "title": "A Função filter()",
          "contentType": "text",
          "order": 2,
          "content": "## Filtragem com filter()\n\nA função `filter` seleciona elementos de uma coleção que satisfaçam uma condição.\n\n```python\nnumeros = [1, 2, 3, 4, 5]\npares = list(filter(lambda x: x % 2 == 0, numeros))\nprint(pares)  # Saída: [2, 4]\n```\n\nA função de seleção deve retornar `True` ou `False` para cada elemento. Apenas elementos que retornam `True` são incluídos no resultado.\n\n### Combinando map e filter\n\nVocê pode combinar ambas as funções:\n\n```python\nnumeros = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Primeiro filtra os pares, depois eleva ao quadrado\npares_quadrados = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, numeros)))\nprint(pares_quadrados)  # Saída: [4, 16, 36, 64, 100]\n```\n\n### Usando Função Normal com filter\n\nPara condições mais complexas:\n\n```python\ndef e_valido(palavra):\n    return len(palavra) > 3 and palavra[0].isupper()\n\npalavras = [\"Olá\", \"mundo\", \"Python\", \"é\", \"Incrível\"]\nvalidas = list(filter(e_valido, palavras))\nprint(validas)  # Saída: ['Python', 'Incrível']\n```"
        },
        {
          "title": "Exercício: Map e Filter",
          "contentType": "exercise",
          "order": 3,
          "exercise": {
            "problem": "Dada uma lista de palavras, use `filter` e `map` para:\n1. Filtrar apenas palavras com mais de 3 caracteres\n2. Converter as palavras filtradas para maiúsculas\n\nExemplo:\n- Entrada: `['olá', 'mundo', 'py', 'python', 'é', 'legal']`\n- Saída: `['MUNDO', 'PYTHON', 'LEGAL']`",
            "starterCode": "def processar_palavras(palavras):\n    # Seu código aqui usando filter e map\n    pass\n\n# Teste\npalavras = ['olá', 'mundo', 'py', 'python', 'é', 'legal']\nprint(processar_palavras(palavras))",
            "testCases": [
              {
                "input": "['olá', 'mundo', 'py', 'python', 'é', 'legal']",
                "expected": "['MUNDO', 'PYTHON', 'LEGAL']"
              },
              {
                "input": "['a', 'ab', 'abc', 'abcd']",
                "expected": "['ABCD']"
              }
            ],
            "hints": [
              "Use filter com lambda x: len(x) > 3",
              "Use map com lambda x: x.upper()",
              "Combine: map(..., filter(...))"
            ],
            "solution": "def processar_palavras(palavras):\n    filtradas = filter(lambda x: len(x) > 3, palavras)\n    maiusculas = map(lambda x: x.upper(), filtradas)\n    return list(maiusculas)"
          }
        },
        {
          "title": "Quiz: Map e Filter",
          "contentType": "quiz",
          "order": 4,
          "quiz": {
            "questions": [
              {
                "question": "O que `list(map(lambda x: x*2, [1, 2, 3]))` retorna?",
                "options": ["[1, 2, 3]", "[2, 4, 6]", "[1, 4, 9]", "Erro"],
                "correctAnswer": 1,
                "explanation": "map aplica a função (x*2) a cada elemento, resultando em [2, 4, 6]."
              },
              {
                "question": "Qual função seleciona apenas elementos que satisfazem uma condição?",
                "options": ["map", "filter", "reduce", "select"],
                "correctAnswer": 1,
                "explanation": "filter seleciona elementos onde a função retorna True."
              },
              {
                "question": "Por que usamos `list()` com map e filter?",
                "options": [
                  "Para evitar erros",
                  "Porque map e filter retornam iteradores, não listas",
                  "Para melhorar performance",
                  "Não é necessário usar list()"
                ],
                "correctAnswer": 1,
                "explanation": "map e filter retornam objetos iteradores. Usamos list() para materializar os resultados em uma lista."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Comprehensions",
      "slug": "comprehensions",
      "description": "Domine a sintaxe elegante de List, Set e Dict Comprehensions.",
      "order": 5,
      "duration": 900,
      "sections": [
        {
          "title": "List Comprehension",
          "contentType": "text",
          "order": 1,
          "content": "## List Comprehension\n\n*Comprehension* é uma sintaxe compacta e elegante para criar coleções a partir de outras coleções. É uma das características mais distintas do Python.\n\n### Sintaxe Básica\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nquadrados = [x**2 for x in numeros]\nprint(quadrados)  # Saída: [1, 4, 9, 16, 25]\n```\n\n### Com Condição (Filtro)\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nquadrados = [x**2 for x in numeros if x % 2 == 0]\nprint(quadrados)  # Saída: [4, 16]\n```\n\nA condição `if x % 2 == 0` filtra apenas os números pares antes de elevar ao quadrado.\n\n### Equivalência com map/filter\n\nList comprehension combina `map` e `filter` em uma sintaxe mais legível:\n\n```python\n# Com map e filter\nresultado = list(map(lambda x: x**2, filter(lambda x: x % 2 == 0, numeros)))\n\n# Com list comprehension (mais legível)\nresultado = [x**2 for x in numeros if x % 2 == 0]\n```"
        },
        {
          "title": "Set e Dict Comprehension",
          "contentType": "text",
          "order": 2,
          "content": "## Set Comprehension\n\nUse chaves para criar conjuntos (elementos únicos):\n\n```python\nnumeros = [1, 2, 3, 2, -5, 4, 3, 1, -2]\nquadrados_unicos = {x**2 for x in numeros if x > 0}\nprint(quadrados_unicos)  # Saída: {16, 1, 4, 9}\n```\n\nA ordem não é garantida em conjuntos.\n\n## Dict Comprehension\n\nPara criar dicionários, defina pares `chave: valor`:\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nquadrados = {x: x**2 for x in numeros}\nprint(quadrados)  # Saída: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}\n```\n\n### Com Condição\n\n```python\nnumeros = [1, 2, 3, 4, 5]\nquadrados = {x: x**2 for x in numeros if x < 5}\nprint(quadrados)  # Saída: {1: 1, 2: 4, 3: 9, 4: 16}\n```"
        },
        {
          "title": "Comprehensions Avançadas",
          "contentType": "text",
          "order": 3,
          "content": "## Produzindo Tipos Diferentes\n\nVocê pode criar elementos de tipos diferentes do original:\n\n```python\nnumeros = [1, 2, 3, 4, 5]\ntuplas = [(x, x**2) for x in numeros if x < 4]\nprint(tuplas)  # Saída: [(1, 1), (2, 4), (3, 9)]\n```\n\n## Iterações Aninhadas\n\nAchatar uma matriz 3x3:\n\n```python\nmatriz = [(1, 4, 25), (2, 7, 18), (3, 11, 47)]\nelementos = [e for l in matriz for e in l]\nprint(elementos)  # Saída: [1, 4, 25, 2, 7, 18, 3, 11, 47]\n```\n\n## Múltiplas Condições\n\n```python\nfrase = \"Esta é uma frase de exemplo para ser processada.\"\npalavras = frase.split()\nselecionadas = [p for p in palavras if len(p) > 2 if p.endswith(\"o\") or p.endswith(\"a\")]\nprint(selecionadas)  # Saída: ['Esta', 'uma', 'frase', 'exemplo', 'para', 'processada.']\n```\n\nVocê pode usar operadores lógicos `and`/`or` ou múltiplos `if`."
        },
        {
          "title": "Exercício: Comprehensions",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Use Dict Comprehension para criar um dicionário onde:\n- As chaves são números de 1 a 10\n- Os valores são 'par' ou 'ímpar' dependendo do número\n\nExemplo de saída:\n`{1: 'ímpar', 2: 'par', 3: 'ímpar', ..., 10: 'par'}`",
            "starterCode": "def criar_dicionario_paridade():\n    # Seu código aqui usando dict comprehension\n    pass\n\nprint(criar_dicionario_paridade())",
            "testCases": [
              {
                "input": "",
                "expected": "{1: 'ímpar', 2: 'par', 3: 'ímpar', 4: 'par', 5: 'ímpar', 6: 'par', 7: 'ímpar', 8: 'par', 9: 'ímpar', 10: 'par'}"
              }
            ],
            "hints": [
              "Use range(1, 11) para gerar números de 1 a 10",
              "Use operador ternário: 'par' if x % 2 == 0 else 'ímpar'"
            ],
            "solution": "def criar_dicionario_paridade():\n    return {x: 'par' if x % 2 == 0 else 'ímpar' for x in range(1, 11)}"
          }
        },
        {
          "title": "Quiz: Comprehensions",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "Qual a diferença entre `[x for x in lista]` e `{x for x in lista}`?",
                "options": [
                  "Não há diferença",
                  "O primeiro cria lista, o segundo cria conjunto (elementos únicos)",
                  "O primeiro cria conjunto, o segundo cria lista",
                  "O segundo gera erro"
                ],
                "correctAnswer": 1,
                "explanation": "Colchetes criam lista; chaves criam conjunto (set), que mantém apenas elementos únicos."
              },
              {
                "question": "O que `{x: x**2 for x in [1, 2, 3]}` retorna?",
                "options": ["{1, 4, 9}", "[1, 4, 9]", "{1: 1, 2: 4, 3: 9}", "[(1, 1), (2, 4), (3, 9)]"],
                "correctAnswer": 2,
                "explanation": "A sintaxe chave: valor dentro de chaves cria um dicionário."
              },
              {
                "question": "Qual comprehension cria uma lista de tuplas (n, n**2) para n de 1 a 3?",
                "options": [
                  "[(n, n**2) for n in range(1, 4)]",
                  "{(n, n**2) for n in range(1, 4)}",
                  "[n, n**2 for n in range(1, 4)]",
                  "(n, n**2 for n in range(1, 4))"
                ],
                "correctAnswer": 0,
                "explanation": "Use colchetes para lista e parênteses para definir a tupla dentro da expressão."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Combinando Coleções e Conjuntos",
      "slug": "combinando-colecoes-conjuntos",
      "description": "Aprenda a combinar coleções com zip e realizar operações com conjuntos.",
      "order": 6,
      "duration": 600,
      "sections": [
        {
          "title": "A Função zip()",
          "contentType": "text",
          "order": 1,
          "content": "## Combinando Coleções com zip()\n\nA função `zip` combina duas ou mais coleções em uma coleção de tuplas, pareando elementos de mesmo índice.\n\n```python\nnomes = [\"João\", \"José\", \"Maria\", \"Pedro\"]\nidades = [25, 30, 20]\n\npessoas = zip(nomes, idades)\nfor nome, idade in pessoas:\n    print(f\"{nome} tem {idade} anos\")\n\n# Saída:\n# João tem 25 anos\n# José tem 30 anos\n# Maria tem 20 anos\n```\n\n**Importante:** Se uma coleção tiver mais elementos que a outra, os elementos extras são ignorados. \"Pedro\" não aparece porque não tem idade correspondente.\n\n### Convertendo para Lista ou Dicionário\n\n```python\nnomes = [\"a\", \"b\", \"c\"]\nvalores = [1, 2, 3]\n\n# Lista de tuplas\nlista = list(zip(nomes, valores))\nprint(lista)  # [('a', 1), ('b', 2), ('c', 3)]\n\n# Dicionário\ndicionario = dict(zip(nomes, valores))\nprint(dicionario)  # {'a': 1, 'b': 2, 'c': 3}\n```"
        },
        {
          "title": "Operações com Conjuntos",
          "contentType": "text",
          "order": 2,
          "content": "## Operações com Conjuntos\n\nConjuntos são ideais para remover duplicatas e realizar operações matemáticas.\n\n### Removendo Duplicatas\n\n```python\nnumeros1 = [1, 2, 3, 4, 5, 3]\nconjunto1 = set(numeros1)\nprint(conjunto1)  # {1, 2, 3, 4, 5}\n```\n\n### União, Interseção e Diferença\n\n```python\nnumeros1 = [1, 2, 3, 4, 5, 3]\nnumeros2 = [3, 4, 5, 6, 7]\nconjunto1 = set(numeros1)\nconjunto2 = set(numeros2)\n\nuniao = conjunto1.union(conjunto2)\nprint(uniao)  # {1, 2, 3, 4, 5, 6, 7}\n\nintersecao = conjunto1.intersection(conjunto2)\nprint(intersecao)  # {3, 4, 5}\n\ndiferenca = conjunto1.difference(conjunto2)\nprint(diferenca)  # {1, 2}\n```\n\nA união não retorna elementos repetidos. A interseção retorna valores presentes em ambos. A diferença retorna elementos de `conjunto1` que não estão em `conjunto2`."
        },
        {
          "title": "Exercício: Zip e Conjuntos",
          "contentType": "exercise",
          "order": 3,
          "exercise": {
            "problem": "Dadas duas listas de números de mesmo tamanho, crie uma função que retorne uma lista com a média de cada par de elementos correspondentes, mas apenas para pares onde ambos os valores são positivos.\n\nExemplo:\n- lista1: `[10, -5, 20, 30]`\n- lista2: `[20, 10, -10, 40]`\n- Saída: `[15.0, 35.0]` (índices 0 e 3 têm ambos positivos)",
            "starterCode": "def medias_positivos(lista1, lista2):\n    # Use zip e list comprehension\n    pass\n\n# Teste\nl1 = [10, -5, 20, 30]\nl2 = [20, 10, -10, 40]\nprint(medias_positivos(l1, l2))",
            "testCases": [
              {
                "input": "[10, -5, 20, 30], [20, 10, -10, 40]",
                "expected": "[15.0, 35.0]"
              },
              {
                "input": "[1, 2, 3], [4, 5, 6]",
                "expected": "[2.5, 3.5, 4.5]"
              }
            ],
            "hints": [
              "Use zip para parear elementos das duas listas",
              "Use list comprehension com condição if a > 0 and b > 0",
              "A média é (a + b) / 2"
            ],
            "solution": "def medias_positivos(lista1, lista2):\n    return [(a + b) / 2 for a, b in zip(lista1, lista2) if a > 0 and b > 0]"
          }
        },
        {
          "title": "Quiz: Zip e Conjuntos",
          "contentType": "quiz",
          "order": 4,
          "quiz": {
            "questions": [
              {
                "question": "O que acontece com `zip([1,2,3], ['a','b'])` quando convertido para lista?",
                "options": [
                  "[(1,'a'), (2,'b'), (3,None)]",
                  "[(1,'a'), (2,'b')]",
                  "Gera erro",
                  "[(1,'a'), (2,'b'), (3,'')]"
                ],
                "correctAnswer": 1,
                "explanation": "zip para no menor tamanho. Elementos extras são ignorados."
              },
              {
                "question": "Como criar um dicionário a partir de duas listas usando zip?",
                "options": [
                  "zip(chaves, valores)",
                  "dict(zip(chaves, valores))",
                  "list(zip(chaves, valores))",
                  "{zip(chaves, valores)}"
                ],
                "correctAnswer": 1,
                "explanation": "dict() converte uma sequência de pares (tuplas) em dicionário."
              },
              {
                "question": "Qual operação de conjunto retorna elementos que estão em A mas não em B?",
                "options": ["A.union(B)", "A.intersection(B)", "A.difference(B)", "A.symmetric_difference(B)"],
                "correctAnswer": 2,
                "explanation": "difference(B) retorna elementos de A que não estão em B."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Sorteio e Módulo Random",
      "slug": "sorteio-modulo-random",
      "description": "Aprenda a selecionar elementos aleatórios de coleções usando o módulo random.",
      "order": 7,
      "duration": 540,
      "sections": [
        {
          "title": "Função random.choice()",
          "contentType": "text",
          "order": 1,
          "content": "## Sorteando Itens de Coleções\n\nA função `random.choice` seleciona aleatoriamente um elemento de uma coleção.\n\n### Em Listas\n\n```python\nimport random\n\nlista = [1, 2, 3, 4, 5]\nelemento_aleatorio = random.choice(lista)\nprint(elemento_aleatorio)\n```\n\n### Em Strings\n\n```python\nimport random\n\nstring = \"Olá, Python!\"\ncaractere_aleatorio = random.choice(string)\nprint(caractere_aleatorio)\n```\n\n### Em Tuplas\n\n```python\nimport random\n\ntupla = (\"maçã\", \"banana\", \"cereja\")\nitem_aleatorio = random.choice(tupla)\nprint(item_aleatorio)\n```"
        },
        {
          "title": "Sorteio em Dicionários",
          "contentType": "text",
          "order": 2,
          "content": "## Sorteando Chaves de Dicionários\n\n`random.choice` não funciona diretamente em dicionários. Converta as chaves ou valores para lista primeiro:\n\n```python\nimport random\n\nfrutas = {1: \"Banana\", 2: \"Morango\", 3: \"Uva\"}\nchaves = list(frutas.keys())\nchave_aleatoria = random.choice(chaves)\nprint(chave_aleatoria)\nprint(frutas[chave_aleatoria])\n```\n\n### Outras Funções Úteis\n\n```python\nimport random\n\nlista = [1, 2, 3, 4, 5]\n\n# Embaralhar lista (modifica a original)\nrandom.shuffle(lista)\nprint(lista)\n\n# Selecionar múltiplos elementos (sem repetição)\namostra = random.sample([1,2,3,4,5], 3)\nprint(amostra)  # Ex: [2, 5, 1]\n\n# Número aleatório em um intervalo\nnum = random.randint(1, 10)\nprint(num)\n```"
        },
        {
          "title": "Exercício: Random",
          "contentType": "exercise",
          "order": 3,
          "exercise": {
            "problem": "Crie uma função que simule um jogo de dados:\n1. Lance dois dados (números de 1 a 6)\n2. Retorne uma tupla com (dado1, dado2, soma)\n\nUse `random.randint(1, 6)` para cada dado.",
            "starterCode": "import random\n\ndef lancar_dados():\n    # Seu código aqui\n    pass\n\n# Teste (execute várias vezes)\nfor i in range(3):\n    resultado = lancar_dados()\n    print(f\"Dado 1: {resultado[0]}, Dado 2: {resultado[1]}, Soma: {resultado[2]}\")",
            "testCases": [
              {
                "input": "",
                "expected": "Tupla com 3 valores, onde cada dado está entre 1-6 e soma é correta"
              }
            ],
            "hints": [
              "Use random.randint(1, 6) para cada dado",
              "Retorne (dado1, dado2, dado1 + dado2)"
            ],
            "solution": "import random\n\ndef lancar_dados():\n    dado1 = random.randint(1, 6)\n    dado2 = random.randint(1, 6)\n    return (dado1, dado2, dado1 + dado2)"
          }
        },
        {
          "title": "Quiz: Módulo Random",
          "contentType": "quiz",
          "order": 4,
          "quiz": {
            "questions": [
              {
                "question": "Qual função seleciona um elemento aleatório de uma lista?",
                "options": ["random.select()", "random.choice()", "random.pick()", "random.get()"],
                "correctAnswer": 1,
                "explanation": "random.choice() seleciona um elemento aleatório de uma sequência."
              },
              {
                "question": "Por que `random.choice(dicionario)` não funciona diretamente?",
                "options": [
                  "Dicionários não são sequências",
                  "Dicionários são muito grandes",
                  "choice só funciona com números",
                  "Funciona normalmente"
                ],
                "correctAnswer": 0,
                "explanation": "Dicionários não são sequências. Converta as chaves ou valores para lista primeiro."
              },
              {
                "question": "Qual função seleciona N elementos sem repetição?",
                "options": ["random.choices()", "random.sample()", "random.choice()", "random.select()"],
                "correctAnswer": 1,
                "explanation": "random.sample(seq, n) retorna n elementos únicos da sequência."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Módulo Collections",
      "slug": "modulo-collections",
      "description": "Conheça estruturas de dados especializadas: Counter, defaultdict, deque e namedtuple.",
      "order": 8,
      "duration": 900,
      "sections": [
        {
          "title": "Counter",
          "contentType": "text",
          "order": 1,
          "content": "## Counter: Contando Elementos\n\n`Counter` é uma subclasse de dicionário especializada em contar elementos.\n\n```python\nfrom collections import Counter\n\n# Contando letras em uma string\ntexto = \"abracadabra\"\ncontador = Counter(texto)\nprint(contador)\n# Saída: Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})\n\n# Contando palavras em uma lista\npalavras = ['python', 'java', 'python', 'c++', 'java', 'python']\ncontador_palavras = Counter(palavras)\nprint(contador_palavras)\n# Saída: Counter({'python': 3, 'java': 2, 'c++': 1})\n\n# Encontrando os elementos mais comuns\nprint(contador_palavras.most_common(2))\n# Saída: [('python', 3), ('java', 2)]\n```\n\nO método `most_common(n)` retorna os n elementos mais frequentes."
        },
        {
          "title": "defaultdict e deque",
          "contentType": "text",
          "order": 2,
          "content": "## defaultdict: Valores Padrão\n\n`defaultdict` nunca gera `KeyError`. Cria automaticamente a chave com valor padrão:\n\n```python\nfrom collections import defaultdict\n\n# Com dicionário comum (precisa verificar)\ncontagem_normal = {}\nfor palavra in ['a', 'b', 'a']:\n    if palavra not in contagem_normal:\n        contagem_normal[palavra] = 0\n    contagem_normal[palavra] += 1\n\n# Com defaultdict (mais simples)\ncontagem = defaultdict(int)  # int() retorna 0\nfor palavra in ['a', 'b', 'a']:\n    contagem[palavra] += 1  # Não precisa verificar!\n\nprint(dict(contagem))  # {'a': 2, 'b': 1}\n```\n\n## deque: Fila de Duas Pontas\n\n`deque` é otimizado para inserções/remoções em ambas as extremidades:\n\n```python\nfrom collections import deque\n\nfila = deque([1, 2, 3])\nfila.append(4)      # Adiciona à direita\nfila.appendleft(0)  # Adiciona à esquerda\nprint(list(fila))   # [0, 1, 2, 3, 4]\n\nfila.pop()          # Remove da direita\nfila.popleft()      # Remove da esquerda\nprint(list(fila))   # [1, 2, 3]\n```"
        },
        {
          "title": "namedtuple",
          "contentType": "text",
          "order": 3,
          "content": "## namedtuple: Tuplas com Campos Nomeados\n\n`namedtuple` permite acesso aos elementos por nome, tornando o código mais legível:\n\n```python\nfrom collections import namedtuple\n\n# Definir a estrutura\nPessoa = namedtuple('Pessoa', ['nome', 'idade', 'cidade'])\n\n# Criar instâncias\npessoa1 = Pessoa('João', 30, 'São Paulo')\npessoa2 = Pessoa(nome='Maria', idade=25, cidade='Rio')\n\n# Acessar por nome (mais legível)\nprint(pessoa1.nome)    # João\nprint(pessoa1.idade)   # 30\n\n# Acessar por índice (como tupla)\nprint(pessoa1[0])      # João\n\n# Desempacotar como tupla\nnome, idade, cidade = pessoa2\nprint(f\"{nome} tem {idade} anos\")  # Maria tem 25 anos\n```\n\nCompare `pessoa.nome` (claro) com `pessoa[0]` (ambíguo)."
        },
        {
          "title": "Exercício: Collections",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Use `Counter` para criar uma função que receba um texto e retorne as 3 palavras mais frequentes (ignorando maiúsculas/minúsculas).\n\nExemplo:\n- Entrada: `\"Python é legal. Python é fácil. Python é poderoso.\"`\n- Saída: `[('python', 3), ('é', 3), ('legal.', 1)]`",
            "starterCode": "from collections import Counter\n\ndef palavras_mais_frequentes(texto, n=3):\n    # Seu código aqui\n    pass\n\n# Teste\ntexto = \"Python é legal. Python é fácil. Python é poderoso.\"\nprint(palavras_mais_frequentes(texto))",
            "testCases": [
              {
                "input": "\"Python é legal. Python é fácil. Python é poderoso.\"",
                "expected": "[('python', 3), ('é', 3), ...]"
              }
            ],
            "hints": [
              "Use texto.lower() para ignorar maiúsculas",
              "Use texto.split() para separar palavras",
              "Use Counter(palavras).most_common(n)"
            ],
            "solution": "from collections import Counter\n\ndef palavras_mais_frequentes(texto, n=3):\n    palavras = texto.lower().split()\n    contador = Counter(palavras)\n    return contador.most_common(n)"
          }
        },
        {
          "title": "Quiz: Módulo Collections",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "O que `Counter('abracadabra').most_common(1)` retorna?",
                "options": ["'a'", "5", "[('a', 5)]", "{'a': 5}"],
                "correctAnswer": 2,
                "explanation": "most_common(n) retorna uma lista de tuplas (elemento, contagem)."
              },
              {
                "question": "Qual a vantagem do defaultdict sobre um dicionário comum?",
                "options": [
                  "É mais rápido",
                  "Cria automaticamente valores padrão para chaves inexistentes",
                  "Usa menos memória",
                  "Permite chaves duplicadas"
                ],
                "correctAnswer": 1,
                "explanation": "defaultdict evita KeyError criando automaticamente valores padrão."
              },
              {
                "question": "Quando usar namedtuple em vez de tupla comum?",
                "options": [
                  "Quando precisar de mais performance",
                  "Quando quiser acessar elementos por nome para maior legibilidade",
                  "Quando precisar de elementos mutáveis",
                  "Quando a tupla tiver apenas 2 elementos"
                ],
                "correctAnswer": 1,
                "explanation": "namedtuple torna o código mais legível ao permitir acesso por nome."
              }
            ]
          }
        }
      ]
    },
    {
      "title": "Geradores",
      "slug": "geradores",
      "description": "Aprenda a criar sequências infinitas e eficientes com geradores.",
      "order": 9,
      "duration": 780,
      "sections": [
        {
          "title": "Introdução a Geradores",
          "contentType": "text",
          "order": 1,
          "content": "## O que são Geradores?\n\nGeradores são coleções cujos elementos são gerados **dinamicamente**, um de cada vez, conforme a demanda. Diferente de listas, não armazenam todos os elementos em memória.\n\n### Função Geradora\n\nUma função geradora usa a instrução `yield` para retornar valores:\n\n```python\ndef gerar_pares():\n    atual = 0\n    while atual >= 0:\n        yield atual\n        atual += 2\n\npares = gerar_pares()\npar = next(pares)\nwhile par <= 10:\n    print(par, end=\", \")\n    par = next(pares)\n# Saída: 0, 2, 4, 6, 8, 10,\n```\n\n### Como Funciona\n\n1. `gerar_pares()` retorna um objeto **generator**\n2. `next(pares)` executa até o próximo `yield`\n3. O estado (variáveis locais) é mantido entre chamadas\n4. A próxima chamada continua de onde parou"
        },
        {
          "title": "Geradores na Prática",
          "contentType": "text",
          "order": 2,
          "content": "## Sequência de Fibonacci\n\nExemplo clássico de sequência infinita:\n\n```python\ndef fibonacci():\n    a, b = 0, 1\n    while True:\n        yield a\n        a, b = b, a + b\n\nf = fibonacci()\nprint(next(f))  # 0\nprint(next(f))  # 1\nprint(next(f))  # 1\nprint(next(f))  # 2\nprint(next(f))  # 3\n# E assim por diante...\n```\n\n### Vantagens dos Geradores\n\n1. **Eficiência de memória**: Não armazena todos os valores\n2. **Sequências infinitas**: Pode gerar valores indefinidamente\n3. **Processamento sob demanda**: Valores calculados apenas quando necessários\n\n### Múltiplas Instâncias\n\nCada chamada da função geradora cria um novo gerador independente:\n\n```python\nf1 = fibonacci()\nf2 = fibonacci()\n\nprint(next(f1))  # 0\nprint(next(f1))  # 1\nprint(next(f2))  # 0 (f2 é independente)\n```"
        },
        {
          "title": "Generator Expressions",
          "contentType": "text",
          "order": 3,
          "content": "## Expressões Geradoras\n\nSimilar a list comprehension, mas com parênteses:\n\n```python\n# List comprehension (cria lista em memória)\nquadrados_lista = [x**2 for x in range(1000000)]\n\n# Generator expression (cria sob demanda)\nquadrados_gen = (x**2 for x in range(1000000))\n\n# Usar o gerador\nfor i, q in enumerate(quadrados_gen):\n    if i >= 5:\n        break\n    print(q)  # 0, 1, 4, 9, 16\n```\n\n### Quando Usar\n\n- **Lista**: Quando precisa acessar múltiplas vezes ou por índice\n- **Gerador**: Quando processa uma vez ou sequência muito grande/infinita\n\n```python\n# Soma de quadrados (gerador é mais eficiente)\nsoma = sum(x**2 for x in range(1000000))\n```\n\nNão precisa de colchetes dentro de funções como `sum()`, `max()`, `min()`."
        },
        {
          "title": "Exercício: Geradores",
          "contentType": "exercise",
          "order": 4,
          "exercise": {
            "problem": "Crie uma função geradora que produza os primeiros N números da sequência de Fibonacci.\n\nExemplo:\n- `list(fib_limitado(7))` deve retornar `[0, 1, 1, 2, 3, 5, 8]`",
            "starterCode": "def fib_limitado(n):\n    # Seu código aqui - use yield\n    pass\n\n# Teste\nprint(list(fib_limitado(7)))\nprint(list(fib_limitado(10)))",
            "testCases": [
              {
                "input": "7",
                "expected": "[0, 1, 1, 2, 3, 5, 8]"
              },
              {
                "input": "10",
                "expected": "[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]"
              }
            ],
            "hints": [
              "Use um contador para limitar a quantidade",
              "Mantenha duas variáveis a e b para os números anteriores",
              "Use yield para retornar cada número"
            ],
            "solution": "def fib_limitado(n):\n    a, b = 0, 1\n    count = 0\n    while count < n:\n        yield a\n        a, b = b, a + b\n        count += 1"
          }
        },
        {
          "title": "Quiz: Geradores",
          "contentType": "quiz",
          "order": 5,
          "quiz": {
            "questions": [
              {
                "question": "Qual a principal vantagem de geradores sobre listas?",
                "options": [
                  "São mais rápidos",
                  "Permitem indexação",
                  "Não armazenam todos os valores em memória",
                  "Podem conter tipos diferentes"
                ],
                "correctAnswer": 2,
                "explanation": "Geradores produzem valores sob demanda, economizando memória."
              },
              {
                "question": "O que a instrução `yield` faz em uma função?",
                "options": [
                  "Termina a função",
                  "Retorna um valor e pausa a execução, mantendo o estado",
                  "Cria uma lista",
                  "Gera um erro"
                ],
                "correctAnswer": 1,
                "explanation": "yield retorna um valor e pausa a função, que continua na próxima chamada a next()."
              },
              {
                "question": "Qual a diferença entre `[x for x in seq]` e `(x for x in seq)`?",
                "options": [
                  "Não há diferença",
                  "O primeiro cria lista; o segundo cria gerador",
                  "O segundo gera erro",
                  "O primeiro é mais lento"
                ],
                "correctAnswer": 1,
                "explanation": "Colchetes criam list comprehension; parênteses criam generator expression."
              }
            ]
          }
        }
      ]
    }
  ]
}
